/*
CircleCI API

This describes the resources that make up the CircleCI API v2.

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// InsightsApiService InsightsApi service
type InsightsApiService service

type ApiGetAllInsightsBranchesRequest struct {
	ctx          context.Context
	ApiService   *InsightsApiService
	projectSlug  string
	workflowName *string
}

// The name of a workflow. If not passed we will scope the API call to the project.
func (r ApiGetAllInsightsBranchesRequest) WorkflowName(workflowName string) ApiGetAllInsightsBranchesRequest {
	r.workflowName = &workflowName
	return r
}

func (r ApiGetAllInsightsBranchesRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GetAllInsightsBranchesExecute(r)
}

/*
GetAllInsightsBranches Get all branches for a project

Get a list of all branches for a specified project. The list will only contain branches currently available within Insights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @return ApiGetAllInsightsBranchesRequest
*/
func (a *InsightsApiService) GetAllInsightsBranches(ctx context.Context, projectSlug string) ApiGetAllInsightsBranchesRequest {
	return ApiGetAllInsightsBranchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectSlug: projectSlug,
	}
}

// Execute executes the request
//  @return interface{}
func (a *InsightsApiService) GetAllInsightsBranchesExecute(r ApiGetAllInsightsBranchesRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetAllInsightsBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workflowName != nil {
		localVarQueryParams.Add("workflow-name", parameterToString(*r.workflowName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlakyTestsRequest struct {
	ctx         context.Context
	ApiService  *InsightsApiService
	projectSlug string
}

func (r ApiGetFlakyTestsRequest) Execute() (*InlineResponse2005, *http.Response, error) {
	return r.ApiService.GetFlakyTestsExecute(r)
}

/*
GetFlakyTests Get flaky tests for a project

Get a list of flaky tests for a given project. Flaky tests are branch agnostic.
             A flaky test is a test that passed and faliled in the same commit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @return ApiGetFlakyTestsRequest
*/
func (a *InsightsApiService) GetFlakyTests(ctx context.Context, projectSlug string) ApiGetFlakyTestsRequest {
	return ApiGetFlakyTestsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectSlug: projectSlug,
	}
}

// Execute executes the request
//  @return InlineResponse2005
func (a *InsightsApiService) GetFlakyTestsExecute(r ApiGetFlakyTestsRequest) (*InlineResponse2005, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetFlakyTests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/flaky-tests"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobTimeseriesRequest struct {
	ctx                   context.Context
	ApiService            *InsightsApiService
	projectSlug           string
	workflowName          string
	branch                *string
	timeseriesGranularity *string
	startDate             *time.Time
	endDate               *time.Time
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetJobTimeseriesRequest) Branch(branch string) ApiGetJobTimeseriesRequest {
	r.branch = &branch
	return r
}

// The granularity for which to query timeseries data.
func (r ApiGetJobTimeseriesRequest) TimeseriesGranularity(timeseriesGranularity string) ApiGetJobTimeseriesRequest {
	r.timeseriesGranularity = &timeseriesGranularity
	return r
}

// Include only executions that started at or after this date. This must be specified if an end-date is provided.
func (r ApiGetJobTimeseriesRequest) StartDate(startDate time.Time) ApiGetJobTimeseriesRequest {
	r.startDate = &startDate
	return r
}

// Include only executions that started before this date. This date can be at most 90 days after the start-date.
func (r ApiGetJobTimeseriesRequest) EndDate(endDate time.Time) ApiGetJobTimeseriesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetJobTimeseriesRequest) Execute() (*InlineResponse2003, *http.Response, error) {
	return r.ApiService.GetJobTimeseriesExecute(r)
}

/*
GetJobTimeseries Job timeseries data

Get timeseries data for all jobs within a workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @return ApiGetJobTimeseriesRequest
*/
func (a *InsightsApiService) GetJobTimeseries(ctx context.Context, projectSlug string, workflowName string) ApiGetJobTimeseriesRequest {
	return ApiGetJobTimeseriesRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
	}
}

// Execute executes the request
//  @return InlineResponse2003
func (a *InsightsApiService) GetJobTimeseriesExecute(r ApiGetJobTimeseriesRequest) (*InlineResponse2003, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2003
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetJobTimeseries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/time-series/{project-slug}/workflows/{workflow-name}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.timeseriesGranularity != nil {
		localVarQueryParams.Add("timeseries-granularity", parameterToString(*r.timeseriesGranularity, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("start-date", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("end-date", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrgSummaryDataRequest struct {
	ctx             context.Context
	ApiService      *InsightsApiService
	orgSlug         string
	reportingWindow *string
	projectNames    *map[string]interface{}
}

// The time window used to calculate summary metrics.
func (r ApiGetOrgSummaryDataRequest) ReportingWindow(reportingWindow string) ApiGetOrgSummaryDataRequest {
	r.reportingWindow = &reportingWindow
	return r
}

// List of project names.
func (r ApiGetOrgSummaryDataRequest) ProjectNames(projectNames map[string]interface{}) ApiGetOrgSummaryDataRequest {
	r.projectNames = &projectNames
	return r
}

func (r ApiGetOrgSummaryDataRequest) Execute() (*InlineResponse2004, *http.Response, error) {
	return r.ApiService.GetOrgSummaryDataExecute(r)
}

/*
GetOrgSummaryData Get summary metrics with trends for the entire org, and for each project.

Gets aggregated summary metrics with trends for the entire org.
              Also gets aggregated metrics and trends for each project belonging to the org.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgSlug Org slug in the form `vcs-slug/org-name`. The `/` characters may be URL-escaped.
 @return ApiGetOrgSummaryDataRequest
*/
func (a *InsightsApiService) GetOrgSummaryData(ctx context.Context, orgSlug string) ApiGetOrgSummaryDataRequest {
	return ApiGetOrgSummaryDataRequest{
		ApiService: a,
		ctx:        ctx,
		orgSlug:    orgSlug,
	}
}

// Execute executes the request
//  @return InlineResponse2004
func (a *InsightsApiService) GetOrgSummaryDataExecute(r ApiGetOrgSummaryDataRequest) (*InlineResponse2004, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetOrgSummaryData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{org-slug}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"org-slug"+"}", url.PathEscape(parameterToString(r.orgSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reportingWindow != nil {
		localVarQueryParams.Add("reporting-window", parameterToString(*r.reportingWindow, ""))
	}
	if r.projectNames != nil {
		localVarQueryParams.Add("project-names", parameterToString(*r.projectNames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectJobRunsRequest struct {
	ctx          context.Context
	ApiService   *InsightsApiService
	projectSlug  string
	workflowName string
	jobName      string
	branch       *string
	pageToken    *string
	startDate    *time.Time
	endDate      *time.Time
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.     Note - Querying all branches is not supported yet.
func (r ApiGetProjectJobRunsRequest) Branch(branch string) ApiGetProjectJobRunsRequest {
	r.branch = &branch
	return r
}

// A token to retrieve the next page of results.
func (r ApiGetProjectJobRunsRequest) PageToken(pageToken string) ApiGetProjectJobRunsRequest {
	r.pageToken = &pageToken
	return r
}

// Include only executions that started at or after this date. This must be specified if an end-date is provided.
func (r ApiGetProjectJobRunsRequest) StartDate(startDate time.Time) ApiGetProjectJobRunsRequest {
	r.startDate = &startDate
	return r
}

// Include only executions that started before this date. This date can be at most 90 days after the start-date.
func (r ApiGetProjectJobRunsRequest) EndDate(endDate time.Time) ApiGetProjectJobRunsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetProjectJobRunsRequest) Execute() (*InlineResponse2009, *http.Response, error) {
	return r.ApiService.GetProjectJobRunsExecute(r)
}

/*
GetProjectJobRuns Get recent runs of a workflow job

Get recent runs of a job within a workflow. Runs going back at most 90 days are returned. Please note that Insights is not a real time financial reporting tool and should not be used for credit reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @param jobName The name of the job.
 @return ApiGetProjectJobRunsRequest
*/
func (a *InsightsApiService) GetProjectJobRuns(ctx context.Context, projectSlug string, workflowName string, jobName string) ApiGetProjectJobRunsRequest {
	return ApiGetProjectJobRunsRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
		jobName:      jobName,
	}
}

// Execute executes the request
//  @return InlineResponse2009
func (a *InsightsApiService) GetProjectJobRunsExecute(r ApiGetProjectJobRunsRequest) (*InlineResponse2009, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectJobRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows/{workflow-name}/jobs/{job-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job-name"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page-token", parameterToString(*r.pageToken, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("start-date", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("end-date", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWorkflowJobMetricsRequest struct {
	ctx             context.Context
	ApiService      *InsightsApiService
	projectSlug     string
	workflowName    string
	pageToken       *string
	allBranches     *bool
	branch          *string
	reportingWindow *string
}

// A token to retrieve the next page of results.
func (r ApiGetProjectWorkflowJobMetricsRequest) PageToken(pageToken string) ApiGetProjectWorkflowJobMetricsRequest {
	r.pageToken = &pageToken
	return r
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetProjectWorkflowJobMetricsRequest) AllBranches(allBranches bool) ApiGetProjectWorkflowJobMetricsRequest {
	r.allBranches = &allBranches
	return r
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetProjectWorkflowJobMetricsRequest) Branch(branch string) ApiGetProjectWorkflowJobMetricsRequest {
	r.branch = &branch
	return r
}

// The time window used to calculate summary metrics.
func (r ApiGetProjectWorkflowJobMetricsRequest) ReportingWindow(reportingWindow string) ApiGetProjectWorkflowJobMetricsRequest {
	r.reportingWindow = &reportingWindow
	return r
}

func (r ApiGetProjectWorkflowJobMetricsRequest) Execute() (*InlineResponse2008, *http.Response, error) {
	return r.ApiService.GetProjectWorkflowJobMetricsExecute(r)
}

/*
GetProjectWorkflowJobMetrics Get summary metrics for a project workflow's jobs.

Get summary metrics for a project workflow's jobs. Job runs going back at most 90 days are included in the aggregation window. Metrics are refreshed daily, and thus may not include executions from the last 24 hours. Please note that Insights is not a real time financial reporting tool and should not be used for credit reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @return ApiGetProjectWorkflowJobMetricsRequest
*/
func (a *InsightsApiService) GetProjectWorkflowJobMetrics(ctx context.Context, projectSlug string, workflowName string) ApiGetProjectWorkflowJobMetricsRequest {
	return ApiGetProjectWorkflowJobMetricsRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
	}
}

// Execute executes the request
//  @return InlineResponse2008
func (a *InsightsApiService) GetProjectWorkflowJobMetricsExecute(r ApiGetProjectWorkflowJobMetricsRequest) (*InlineResponse2008, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectWorkflowJobMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows/{workflow-name}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		localVarQueryParams.Add("page-token", parameterToString(*r.pageToken, ""))
	}
	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.reportingWindow != nil {
		localVarQueryParams.Add("reporting-window", parameterToString(*r.reportingWindow, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWorkflowMetricsRequest struct {
	ctx             context.Context
	ApiService      *InsightsApiService
	projectSlug     string
	pageToken       *string
	allBranches     *bool
	branch          *string
	reportingWindow *string
}

// A token to retrieve the next page of results.
func (r ApiGetProjectWorkflowMetricsRequest) PageToken(pageToken string) ApiGetProjectWorkflowMetricsRequest {
	r.pageToken = &pageToken
	return r
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetProjectWorkflowMetricsRequest) AllBranches(allBranches bool) ApiGetProjectWorkflowMetricsRequest {
	r.allBranches = &allBranches
	return r
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetProjectWorkflowMetricsRequest) Branch(branch string) ApiGetProjectWorkflowMetricsRequest {
	r.branch = &branch
	return r
}

// The time window used to calculate summary metrics.
func (r ApiGetProjectWorkflowMetricsRequest) ReportingWindow(reportingWindow string) ApiGetProjectWorkflowMetricsRequest {
	r.reportingWindow = &reportingWindow
	return r
}

func (r ApiGetProjectWorkflowMetricsRequest) Execute() (*InlineResponse2006, *http.Response, error) {
	return r.ApiService.GetProjectWorkflowMetricsExecute(r)
}

/*
GetProjectWorkflowMetrics Get summary metrics for a project's workflows

Get summary metrics for a project's workflows. Workflow runs going back at most 90 days are included in the aggregation window. Metrics are refreshed daily, and thus may not include executions from the last 24 hours. Please note that Insights is not a real time financial reporting tool and should not be used for credit reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @return ApiGetProjectWorkflowMetricsRequest
*/
func (a *InsightsApiService) GetProjectWorkflowMetrics(ctx context.Context, projectSlug string) ApiGetProjectWorkflowMetricsRequest {
	return ApiGetProjectWorkflowMetricsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectSlug: projectSlug,
	}
}

// Execute executes the request
//  @return InlineResponse2006
func (a *InsightsApiService) GetProjectWorkflowMetricsExecute(r ApiGetProjectWorkflowMetricsRequest) (*InlineResponse2006, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectWorkflowMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		localVarQueryParams.Add("page-token", parameterToString(*r.pageToken, ""))
	}
	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.reportingWindow != nil {
		localVarQueryParams.Add("reporting-window", parameterToString(*r.reportingWindow, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWorkflowRunsRequest struct {
	ctx          context.Context
	ApiService   *InsightsApiService
	projectSlug  string
	workflowName string
	allBranches  *bool
	branch       *string
	pageToken    *string
	startDate    *time.Time
	endDate      *time.Time
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetProjectWorkflowRunsRequest) AllBranches(allBranches bool) ApiGetProjectWorkflowRunsRequest {
	r.allBranches = &allBranches
	return r
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetProjectWorkflowRunsRequest) Branch(branch string) ApiGetProjectWorkflowRunsRequest {
	r.branch = &branch
	return r
}

// A token to retrieve the next page of results.
func (r ApiGetProjectWorkflowRunsRequest) PageToken(pageToken string) ApiGetProjectWorkflowRunsRequest {
	r.pageToken = &pageToken
	return r
}

// Include only executions that started at or after this date. This must be specified if an end-date is provided.
func (r ApiGetProjectWorkflowRunsRequest) StartDate(startDate time.Time) ApiGetProjectWorkflowRunsRequest {
	r.startDate = &startDate
	return r
}

// Include only executions that started before this date. This date can be at most 90 days after the start-date.
func (r ApiGetProjectWorkflowRunsRequest) EndDate(endDate time.Time) ApiGetProjectWorkflowRunsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetProjectWorkflowRunsRequest) Execute() (*InlineResponse2007, *http.Response, error) {
	return r.ApiService.GetProjectWorkflowRunsExecute(r)
}

/*
GetProjectWorkflowRuns Get recent runs of a workflow

Get recent runs of a workflow. Runs going back at most 90 days are returned. Please note that Insights is not a real time financial reporting tool and should not be used for credit reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @return ApiGetProjectWorkflowRunsRequest
*/
func (a *InsightsApiService) GetProjectWorkflowRuns(ctx context.Context, projectSlug string, workflowName string) ApiGetProjectWorkflowRunsRequest {
	return ApiGetProjectWorkflowRunsRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
	}
}

// Execute executes the request
//  @return InlineResponse2007
func (a *InsightsApiService) GetProjectWorkflowRunsExecute(r ApiGetProjectWorkflowRunsRequest) (*InlineResponse2007, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectWorkflowRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows/{workflow-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page-token", parameterToString(*r.pageToken, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("start-date", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("end-date", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWorkflowTestMetricsRequest struct {
	ctx          context.Context
	ApiService   *InsightsApiService
	projectSlug  string
	workflowName string
	branch       *string
	allBranches  *bool
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetProjectWorkflowTestMetricsRequest) Branch(branch string) ApiGetProjectWorkflowTestMetricsRequest {
	r.branch = &branch
	return r
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetProjectWorkflowTestMetricsRequest) AllBranches(allBranches bool) ApiGetProjectWorkflowTestMetricsRequest {
	r.allBranches = &allBranches
	return r
}

func (r ApiGetProjectWorkflowTestMetricsRequest) Execute() (*InlineResponse20011, *http.Response, error) {
	return r.ApiService.GetProjectWorkflowTestMetricsExecute(r)
}

/*
GetProjectWorkflowTestMetrics Get test metrics for a project's workflows

Get test metrics for a project's workflows. Currently tests metrics are calculated based on 10 most recent workflow runs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @return ApiGetProjectWorkflowTestMetricsRequest
*/
func (a *InsightsApiService) GetProjectWorkflowTestMetrics(ctx context.Context, projectSlug string, workflowName string) ApiGetProjectWorkflowTestMetricsRequest {
	return ApiGetProjectWorkflowTestMetricsRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
	}
}

// Execute executes the request
//  @return InlineResponse20011
func (a *InsightsApiService) GetProjectWorkflowTestMetricsExecute(r ApiGetProjectWorkflowTestMetricsRequest) (*InlineResponse20011, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectWorkflowTestMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows/{workflow-name}/test-metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWorkflowsPageDataRequest struct {
	ctx             context.Context
	ApiService      *InsightsApiService
	projectSlug     string
	reportingWindow *string
	branches        *map[string]interface{}
	workflowNames   *map[string]interface{}
}

// The time window used to calculate summary metrics.
func (r ApiGetProjectWorkflowsPageDataRequest) ReportingWindow(reportingWindow string) ApiGetProjectWorkflowsPageDataRequest {
	r.reportingWindow = &reportingWindow
	return r
}

// The names of VCS branches to include in branch-level workflow metrics.
func (r ApiGetProjectWorkflowsPageDataRequest) Branches(branches map[string]interface{}) ApiGetProjectWorkflowsPageDataRequest {
	r.branches = &branches
	return r
}

// The names of workflows to include in workflow-level metrics.
func (r ApiGetProjectWorkflowsPageDataRequest) WorkflowNames(workflowNames map[string]interface{}) ApiGetProjectWorkflowsPageDataRequest {
	r.workflowNames = &workflowNames
	return r
}

func (r ApiGetProjectWorkflowsPageDataRequest) Execute() (*InlineResponse2002, *http.Response, error) {
	return r.ApiService.GetProjectWorkflowsPageDataExecute(r)
}

/*
GetProjectWorkflowsPageData Get summary metrics and trends for a project across it's workflows and branches

Get summary metrics and trends for a project at workflow and branch level.
             Workflow runs going back at most 90 days are included in the aggregation window.
             Trends are only supported upto last 30 days.
             Metrics are refreshed daily, and thus may not include executions from the last 24 hours.
             Please note that Insights is not a real time financial reporting tool and should not be used for credit reporting.
             The most up to date credit information can be found in Plan Overview in the CircleCI UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @return ApiGetProjectWorkflowsPageDataRequest
*/
func (a *InsightsApiService) GetProjectWorkflowsPageData(ctx context.Context, projectSlug string) ApiGetProjectWorkflowsPageDataRequest {
	return ApiGetProjectWorkflowsPageDataRequest{
		ApiService:  a,
		ctx:         ctx,
		projectSlug: projectSlug,
	}
}

// Execute executes the request
//  @return InlineResponse2002
func (a *InsightsApiService) GetProjectWorkflowsPageDataExecute(r ApiGetProjectWorkflowsPageDataRequest) (*InlineResponse2002, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2002
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetProjectWorkflowsPageData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/pages/{project-slug}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reportingWindow != nil {
		localVarQueryParams.Add("reporting-window", parameterToString(*r.reportingWindow, ""))
	}
	if r.branches != nil {
		localVarQueryParams.Add("branches", parameterToString(*r.branches, ""))
	}
	if r.workflowNames != nil {
		localVarQueryParams.Add("workflow-names", parameterToString(*r.workflowNames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkflowSummaryRequest struct {
	ctx          context.Context
	ApiService   *InsightsApiService
	projectSlug  string
	workflowName string
	allBranches  *bool
	branches     *map[string]interface{}
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetWorkflowSummaryRequest) AllBranches(allBranches bool) ApiGetWorkflowSummaryRequest {
	r.allBranches = &allBranches
	return r
}

// The names of VCS branches to include in branch-level workflow metrics.
func (r ApiGetWorkflowSummaryRequest) Branches(branches map[string]interface{}) ApiGetWorkflowSummaryRequest {
	r.branches = &branches
	return r
}

func (r ApiGetWorkflowSummaryRequest) Execute() (*InlineResponse20010, *http.Response, error) {
	return r.ApiService.GetWorkflowSummaryExecute(r)
}

/*
GetWorkflowSummary Get metrics and trends for workflows

Get the metrics and trends for a particular workflow on a single branch or all branches

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @param workflowName The name of the workflow.
 @return ApiGetWorkflowSummaryRequest
*/
func (a *InsightsApiService) GetWorkflowSummary(ctx context.Context, projectSlug string, workflowName string) ApiGetWorkflowSummaryRequest {
	return ApiGetWorkflowSummaryRequest{
		ApiService:   a,
		ctx:          ctx,
		projectSlug:  projectSlug,
		workflowName: workflowName,
	}
}

// Execute executes the request
//  @return InlineResponse20010
func (a *InsightsApiService) GetWorkflowSummaryExecute(r ApiGetWorkflowSummaryRequest) (*InlineResponse20010, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetWorkflowSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/{project-slug}/workflows/{workflow-name}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow-name"+"}", url.PathEscape(parameterToString(r.workflowName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	if r.branches != nil {
		localVarQueryParams.Add("branches", parameterToString(*r.branches, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkflowTimeseriesRequest struct {
	ctx                   context.Context
	ApiService            *InsightsApiService
	projectSlug           string
	branch                *string
	allBranches           *bool
	timeseriesGranularity *string
	workflowName          *string
	startDate             *time.Time
	endDate               *time.Time
}

// The name of a vcs branch. If not passed we will scope the API call to the default branch.
func (r ApiGetWorkflowTimeseriesRequest) Branch(branch string) ApiGetWorkflowTimeseriesRequest {
	r.branch = &branch
	return r
}

// Whether to retrieve data for all branches combined. Use either this parameter OR the branch name parameter.
func (r ApiGetWorkflowTimeseriesRequest) AllBranches(allBranches bool) ApiGetWorkflowTimeseriesRequest {
	r.allBranches = &allBranches
	return r
}

// The granularity for which to query timeseries data.
func (r ApiGetWorkflowTimeseriesRequest) TimeseriesGranularity(timeseriesGranularity string) ApiGetWorkflowTimeseriesRequest {
	r.timeseriesGranularity = &timeseriesGranularity
	return r
}

// The name of a workflow. If not passed we will scope the API call to the project.
func (r ApiGetWorkflowTimeseriesRequest) WorkflowName(workflowName string) ApiGetWorkflowTimeseriesRequest {
	r.workflowName = &workflowName
	return r
}

// Include only executions that started at or after this date. This must be specified if an end-date is provided.
func (r ApiGetWorkflowTimeseriesRequest) StartDate(startDate time.Time) ApiGetWorkflowTimeseriesRequest {
	r.startDate = &startDate
	return r
}

// Include only executions that started before this date. This date can be at most 90 days after the start-date.
func (r ApiGetWorkflowTimeseriesRequest) EndDate(endDate time.Time) ApiGetWorkflowTimeseriesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetWorkflowTimeseriesRequest) Execute() (*InlineResponse2003, *http.Response, error) {
	return r.ApiService.GetWorkflowTimeseriesExecute(r)
}

/*
GetWorkflowTimeseries Workflow timeseries data

If no query parameters are supplied, will return timeseries data for all workflows that have ran on the default branch.

            When granularity is `hourly`, up to 48 hours of timeseries data will be returned. When granularity is `daily`, up to 90 days of timeseries data will be returned.

            Different combinations of branches and workflow-names can narrow the query further:

             * All workflows, default branch (default, no query parameters)
             * All workflows, all branches: `all-branches=true`
             * All workflows on specific branch: `branch=feature-branch`
             * A specified workflow, all branches: `workflow-name=build&all-branches=true`,
             * A specified branch on a specified workflow: `workflow-name=build&branch=feature-branch`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectSlug Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
 @return ApiGetWorkflowTimeseriesRequest
*/
func (a *InsightsApiService) GetWorkflowTimeseries(ctx context.Context, projectSlug string) ApiGetWorkflowTimeseriesRequest {
	return ApiGetWorkflowTimeseriesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectSlug: projectSlug,
	}
}

// Execute executes the request
//  @return InlineResponse2003
func (a *InsightsApiService) GetWorkflowTimeseriesExecute(r ApiGetWorkflowTimeseriesRequest) (*InlineResponse2003, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineResponse2003
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsApiService.GetWorkflowTimeseries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/time-series/{project-slug}/workflows"
	localVarPath = strings.Replace(localVarPath, "{"+"project-slug"+"}", url.PathEscape(parameterToString(r.projectSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.allBranches != nil {
		localVarQueryParams.Add("all-branches", parameterToString(*r.allBranches, ""))
	}
	if r.timeseriesGranularity != nil {
		localVarQueryParams.Add("timeseries-granularity", parameterToString(*r.timeseriesGranularity, ""))
	}
	if r.workflowName != nil {
		localVarQueryParams.Add("workflow-name", parameterToString(*r.workflowName, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("start-date", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("end-date", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Circle-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_query"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("circle-token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
