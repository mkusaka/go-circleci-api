//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.3, generator: @autorest/go@4.0.0-preview.40)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package client

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// CircleciClient contains the methods for the Circleci group.
// Don't use this type directly, use NewCircleciClient() instead.
type CircleciClient struct {
	pl runtime.Pipeline
}

// NewCircleciClient creates a new instance of CircleciClient with the specified values.
// options - pass nil to accept the default values.
func NewCircleciClient(options *azcore.ClientOptions) *CircleciClient {
	if options == nil {
		options = &azcore.ClientOptions{}
	}
	client := &CircleciClient{
		pl: runtime.NewPipeline(moduleName, moduleVersion, runtime.PipelineOptions{}, options),
	}
	return client
}

// AddEnvironmentVariableToContext - Create or update an environment variable within a context. Returns information about
// the environment variable, not including its value.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// contextID - ID of the context (UUID)
// envVarName - The name of the environment variable
// options - CircleciClientAddEnvironmentVariableToContextOptions contains the optional parameters for the CircleciClient.AddEnvironmentVariableToContext
// method.
func (client *CircleciClient) AddEnvironmentVariableToContext(ctx context.Context, contextID string, envVarName string, options *CircleciClientAddEnvironmentVariableToContextOptions) (CircleciClientAddEnvironmentVariableToContextResponse, error) {
	req, err := client.addEnvironmentVariableToContextCreateRequest(ctx, contextID, envVarName, options)
	if err != nil {
		return CircleciClientAddEnvironmentVariableToContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientAddEnvironmentVariableToContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientAddEnvironmentVariableToContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.addEnvironmentVariableToContextHandleResponse(resp)
}

// addEnvironmentVariableToContextCreateRequest creates the AddEnvironmentVariableToContext request.
func (client *CircleciClient) addEnvironmentVariableToContextCreateRequest(ctx context.Context, contextID string, envVarName string, options *CircleciClientAddEnvironmentVariableToContextOptions) (*policy.Request, error) {
	urlPath := "/context/{context-id}/environment-variable/{env-var-name}"
	urlPath = strings.ReplaceAll(urlPath, "{context-id}", url.PathEscape(contextID))
	if envVarName == "" {
		return nil, errors.New("parameter envVarName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{env-var-name}", url.PathEscape(envVarName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// addEnvironmentVariableToContextHandleResponse handles the AddEnvironmentVariableToContext response.
func (client *CircleciClient) addEnvironmentVariableToContextHandleResponse(resp *http.Response) (CircleciClientAddEnvironmentVariableToContextResponse, error) {
	result := CircleciClientAddEnvironmentVariableToContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Fz7BoxContextIDEnvironmentVariableEnvVarNamePutResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientAddEnvironmentVariableToContextResponse{}, err
	}
	return result, nil
}

// ApprovePendingApprovalJobByID - Approves a pending approval job in a workflow.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// approvalRequestID - The ID of the job being approved.
// id - The unique ID of the workflow.
// options - CircleciClientApprovePendingApprovalJobByIDOptions contains the optional parameters for the CircleciClient.ApprovePendingApprovalJobByID
// method.
func (client *CircleciClient) ApprovePendingApprovalJobByID(ctx context.Context, approvalRequestID string, id string, options *CircleciClientApprovePendingApprovalJobByIDOptions) (CircleciClientApprovePendingApprovalJobByIDResponse, error) {
	req, err := client.approvePendingApprovalJobByIDCreateRequest(ctx, approvalRequestID, id, options)
	if err != nil {
		return CircleciClientApprovePendingApprovalJobByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientApprovePendingApprovalJobByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return CircleciClientApprovePendingApprovalJobByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.approvePendingApprovalJobByIDHandleResponse(resp)
}

// approvePendingApprovalJobByIDCreateRequest creates the ApprovePendingApprovalJobByID request.
func (client *CircleciClient) approvePendingApprovalJobByIDCreateRequest(ctx context.Context, approvalRequestID string, id string, options *CircleciClientApprovePendingApprovalJobByIDOptions) (*policy.Request, error) {
	urlPath := "/workflow/{id}/approve/{approval_request_id}"
	urlPath = strings.ReplaceAll(urlPath, "{approval_request_id}", url.PathEscape(approvalRequestID))
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// approvePendingApprovalJobByIDHandleResponse handles the ApprovePendingApprovalJobByID response.
func (client *CircleciClient) approvePendingApprovalJobByIDHandleResponse(resp *http.Response) (CircleciClientApprovePendingApprovalJobByIDResponse, error) {
	result := CircleciClientApprovePendingApprovalJobByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse7); err != nil {
		return CircleciClientApprovePendingApprovalJobByIDResponse{}, err
	}
	return result, nil
}

// CancelJob - Cancel job with a given job number.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// jobNumber - The number of the job.
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientCancelJobOptions contains the optional parameters for the CircleciClient.CancelJob method.
func (client *CircleciClient) CancelJob(ctx context.Context, jobNumber int32, projectSlug string, options *CircleciClientCancelJobOptions) (CircleciClientCancelJobResponse, error) {
	req, err := client.cancelJobCreateRequest(ctx, jobNumber, projectSlug, options)
	if err != nil {
		return CircleciClientCancelJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCancelJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return CircleciClientCancelJobResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelJobHandleResponse(resp)
}

// cancelJobCreateRequest creates the CancelJob request.
func (client *CircleciClient) cancelJobCreateRequest(ctx context.Context, jobNumber int32, projectSlug string, options *CircleciClientCancelJobOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/job/{job-number}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{job-number}", url.PathEscape(strconv.FormatInt(int64(jobNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelJobHandleResponse handles the CancelJob response.
func (client *CircleciClient) cancelJobHandleResponse(resp *http.Response) (CircleciClientCancelJobResponse, error) {
	result := CircleciClientCancelJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse5); err != nil {
		return CircleciClientCancelJobResponse{}, err
	}
	return result, nil
}

// CancelWorkflow - Cancels a running workflow.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// id - The unique ID of the workflow.
// options - CircleciClientCancelWorkflowOptions contains the optional parameters for the CircleciClient.CancelWorkflow method.
func (client *CircleciClient) CancelWorkflow(ctx context.Context, id string, options *CircleciClientCancelWorkflowOptions) (CircleciClientCancelWorkflowResponse, error) {
	req, err := client.cancelWorkflowCreateRequest(ctx, id, options)
	if err != nil {
		return CircleciClientCancelWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCancelWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return CircleciClientCancelWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelWorkflowHandleResponse(resp)
}

// cancelWorkflowCreateRequest creates the CancelWorkflow request.
func (client *CircleciClient) cancelWorkflowCreateRequest(ctx context.Context, id string, options *CircleciClientCancelWorkflowOptions) (*policy.Request, error) {
	urlPath := "/workflow/{id}/cancel"
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelWorkflowHandleResponse handles the CancelWorkflow response.
func (client *CircleciClient) cancelWorkflowHandleResponse(resp *http.Response) (CircleciClientCancelWorkflowResponse, error) {
	result := CircleciClientCancelWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse8); err != nil {
		return CircleciClientCancelWorkflowResponse{}, err
	}
	return result, nil
}

// ContinuePipeline - Continue a pipeline from the setup phase.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientContinuePipelineOptions contains the optional parameters for the CircleciClient.ContinuePipeline
// method.
func (client *CircleciClient) ContinuePipeline(ctx context.Context, options *CircleciClientContinuePipelineOptions) (CircleciClientContinuePipelineResponse, error) {
	req, err := client.continuePipelineCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientContinuePipelineResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientContinuePipelineResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientContinuePipelineResponse{}, runtime.NewResponseError(resp)
	}
	return client.continuePipelineHandleResponse(resp)
}

// continuePipelineCreateRequest creates the ContinuePipeline request.
func (client *CircleciClient) continuePipelineCreateRequest(ctx context.Context, options *CircleciClientContinuePipelineOptions) (*policy.Request, error) {
	urlPath := "/pipeline/continue"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// continuePipelineHandleResponse handles the ContinuePipeline response.
func (client *CircleciClient) continuePipelineHandleResponse(resp *http.Response) (CircleciClientContinuePipelineResponse, error) {
	result := CircleciClientContinuePipelineResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse2); err != nil {
		return CircleciClientContinuePipelineResponse{}, err
	}
	return result, nil
}

// CreateCheckoutKey - Creates a new checkout key. This API request is only usable with a user API token.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientCreateCheckoutKeyOptions contains the optional parameters for the CircleciClient.CreateCheckoutKey
// method.
func (client *CircleciClient) CreateCheckoutKey(ctx context.Context, projectSlug string, options *CircleciClientCreateCheckoutKeyOptions) (CircleciClientCreateCheckoutKeyResponse, error) {
	req, err := client.createCheckoutKeyCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientCreateCheckoutKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCreateCheckoutKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return CircleciClientCreateCheckoutKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.createCheckoutKeyHandleResponse(resp)
}

// createCheckoutKeyCreateRequest creates the CreateCheckoutKey request.
func (client *CircleciClient) createCheckoutKeyCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientCreateCheckoutKeyOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/checkout-key"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createCheckoutKeyHandleResponse handles the CreateCheckoutKey response.
func (client *CircleciClient) createCheckoutKeyHandleResponse(resp *http.Response) (CircleciClientCreateCheckoutKeyResponse, error) {
	result := CircleciClientCreateCheckoutKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckoutKey); err != nil {
		return CircleciClientCreateCheckoutKeyResponse{}, err
	}
	return result, nil
}

// CreateContext - Create a new context
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientCreateContextOptions contains the optional parameters for the CircleciClient.CreateContext method.
func (client *CircleciClient) CreateContext(ctx context.Context, options *CircleciClientCreateContextOptions) (CircleciClientCreateContextResponse, error) {
	req, err := client.createContextCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientCreateContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCreateContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientCreateContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.createContextHandleResponse(resp)
}

// createContextCreateRequest creates the CreateContext request.
func (client *CircleciClient) createContextCreateRequest(ctx context.Context, options *CircleciClientCreateContextOptions) (*policy.Request, error) {
	urlPath := "/context"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createContextHandleResponse handles the CreateContext response.
func (client *CircleciClient) createContextHandleResponse(resp *http.Response) (CircleciClientCreateContextResponse, error) {
	result := CircleciClientCreateContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Context); err != nil {
		return CircleciClientCreateContextResponse{}, err
	}
	return result, nil
}

// CreateEnvVar - Creates a new environment variable.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientCreateEnvVarOptions contains the optional parameters for the CircleciClient.CreateEnvVar method.
func (client *CircleciClient) CreateEnvVar(ctx context.Context, projectSlug string, options *CircleciClientCreateEnvVarOptions) (CircleciClientCreateEnvVarResponse, error) {
	req, err := client.createEnvVarCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientCreateEnvVarResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCreateEnvVarResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return CircleciClientCreateEnvVarResponse{}, runtime.NewResponseError(resp)
	}
	return client.createEnvVarHandleResponse(resp)
}

// createEnvVarCreateRequest creates the CreateEnvVar request.
func (client *CircleciClient) createEnvVarCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientCreateEnvVarOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/envvar"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createEnvVarHandleResponse handles the CreateEnvVar response.
func (client *CircleciClient) createEnvVarHandleResponse(resp *http.Response) (CircleciClientCreateEnvVarResponse, error) {
	result := CircleciClientCreateEnvVarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentVariablePair); err != nil {
		return CircleciClientCreateEnvVarResponse{}, err
	}
	return result, nil
}

// CreateSchedule - Creates a schedule and returns the created schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientCreateScheduleOptions contains the optional parameters for the CircleciClient.CreateSchedule method.
func (client *CircleciClient) CreateSchedule(ctx context.Context, projectSlug string, options *CircleciClientCreateScheduleOptions) (CircleciClientCreateScheduleResponse, error) {
	req, err := client.createScheduleCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientCreateScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientCreateScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return CircleciClientCreateScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.createScheduleHandleResponse(resp)
}

// createScheduleCreateRequest creates the CreateSchedule request.
func (client *CircleciClient) createScheduleCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientCreateScheduleOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/schedule"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createScheduleHandleResponse handles the CreateSchedule response.
func (client *CircleciClient) createScheduleHandleResponse(resp *http.Response) (CircleciClientCreateScheduleResponse, error) {
	result := CircleciClientCreateScheduleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Schedule); err != nil {
		return CircleciClientCreateScheduleResponse{}, err
	}
	return result, nil
}

// DeleteCheckoutKey - Deletes the checkout key.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// fingerprint - An SSH key fingerprint.
// options - CircleciClientDeleteCheckoutKeyOptions contains the optional parameters for the CircleciClient.DeleteCheckoutKey
// method.
func (client *CircleciClient) DeleteCheckoutKey(ctx context.Context, projectSlug string, fingerprint string, options *CircleciClientDeleteCheckoutKeyOptions) (CircleciClientDeleteCheckoutKeyResponse, error) {
	req, err := client.deleteCheckoutKeyCreateRequest(ctx, projectSlug, fingerprint, options)
	if err != nil {
		return CircleciClientDeleteCheckoutKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientDeleteCheckoutKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientDeleteCheckoutKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteCheckoutKeyHandleResponse(resp)
}

// deleteCheckoutKeyCreateRequest creates the DeleteCheckoutKey request.
func (client *CircleciClient) deleteCheckoutKeyCreateRequest(ctx context.Context, projectSlug string, fingerprint string, options *CircleciClientDeleteCheckoutKeyOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/checkout-key/{fingerprint}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if fingerprint == "" {
		return nil, errors.New("parameter fingerprint cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fingerprint}", url.PathEscape(fingerprint))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCheckoutKeyHandleResponse handles the DeleteCheckoutKey response.
func (client *CircleciClient) deleteCheckoutKeyHandleResponse(resp *http.Response) (CircleciClientDeleteCheckoutKeyResponse, error) {
	result := CircleciClientDeleteCheckoutKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse3); err != nil {
		return CircleciClientDeleteCheckoutKeyResponse{}, err
	}
	return result, nil
}

// DeleteContext - Delete a context
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// contextID - ID of the context (UUID)
// options - CircleciClientDeleteContextOptions contains the optional parameters for the CircleciClient.DeleteContext method.
func (client *CircleciClient) DeleteContext(ctx context.Context, contextID string, options *CircleciClientDeleteContextOptions) (CircleciClientDeleteContextResponse, error) {
	req, err := client.deleteContextCreateRequest(ctx, contextID, options)
	if err != nil {
		return CircleciClientDeleteContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientDeleteContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientDeleteContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteContextHandleResponse(resp)
}

// deleteContextCreateRequest creates the DeleteContext request.
func (client *CircleciClient) deleteContextCreateRequest(ctx context.Context, contextID string, options *CircleciClientDeleteContextOptions) (*policy.Request, error) {
	urlPath := "/context/{context-id}"
	urlPath = strings.ReplaceAll(urlPath, "{context-id}", url.PathEscape(contextID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteContextHandleResponse handles the DeleteContext response.
func (client *CircleciClient) deleteContextHandleResponse(resp *http.Response) (CircleciClientDeleteContextResponse, error) {
	result := CircleciClientDeleteContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse); err != nil {
		return CircleciClientDeleteContextResponse{}, err
	}
	return result, nil
}

// DeleteEnvVar - Deletes the environment variable named :name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// name - The name of the environment variable.
// options - CircleciClientDeleteEnvVarOptions contains the optional parameters for the CircleciClient.DeleteEnvVar method.
func (client *CircleciClient) DeleteEnvVar(ctx context.Context, projectSlug string, name string, options *CircleciClientDeleteEnvVarOptions) (CircleciClientDeleteEnvVarResponse, error) {
	req, err := client.deleteEnvVarCreateRequest(ctx, projectSlug, name, options)
	if err != nil {
		return CircleciClientDeleteEnvVarResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientDeleteEnvVarResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientDeleteEnvVarResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteEnvVarHandleResponse(resp)
}

// deleteEnvVarCreateRequest creates the DeleteEnvVar request.
func (client *CircleciClient) deleteEnvVarCreateRequest(ctx context.Context, projectSlug string, name string, options *CircleciClientDeleteEnvVarOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/envvar/{name}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteEnvVarHandleResponse handles the DeleteEnvVar response.
func (client *CircleciClient) deleteEnvVarHandleResponse(resp *http.Response) (CircleciClientDeleteEnvVarResponse, error) {
	result := CircleciClientDeleteEnvVarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse4); err != nil {
		return CircleciClientDeleteEnvVarResponse{}, err
	}
	return result, nil
}

// DeleteEnvironmentVariableFromContext - Delete an environment variable from a context.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// envVarName - The name of the environment variable
// contextID - ID of the context (UUID)
// options - CircleciClientDeleteEnvironmentVariableFromContextOptions contains the optional parameters for the CircleciClient.DeleteEnvironmentVariableFromContext
// method.
func (client *CircleciClient) DeleteEnvironmentVariableFromContext(ctx context.Context, envVarName string, contextID string, options *CircleciClientDeleteEnvironmentVariableFromContextOptions) (CircleciClientDeleteEnvironmentVariableFromContextResponse, error) {
	req, err := client.deleteEnvironmentVariableFromContextCreateRequest(ctx, envVarName, contextID, options)
	if err != nil {
		return CircleciClientDeleteEnvironmentVariableFromContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientDeleteEnvironmentVariableFromContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientDeleteEnvironmentVariableFromContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteEnvironmentVariableFromContextHandleResponse(resp)
}

// deleteEnvironmentVariableFromContextCreateRequest creates the DeleteEnvironmentVariableFromContext request.
func (client *CircleciClient) deleteEnvironmentVariableFromContextCreateRequest(ctx context.Context, envVarName string, contextID string, options *CircleciClientDeleteEnvironmentVariableFromContextOptions) (*policy.Request, error) {
	urlPath := "/context/{context-id}/environment-variable/{env-var-name}"
	if envVarName == "" {
		return nil, errors.New("parameter envVarName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{env-var-name}", url.PathEscape(envVarName))
	urlPath = strings.ReplaceAll(urlPath, "{context-id}", url.PathEscape(contextID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteEnvironmentVariableFromContextHandleResponse handles the DeleteEnvironmentVariableFromContext response.
func (client *CircleciClient) deleteEnvironmentVariableFromContextHandleResponse(resp *http.Response) (CircleciClientDeleteEnvironmentVariableFromContextResponse, error) {
	result := CircleciClientDeleteEnvironmentVariableFromContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse0); err != nil {
		return CircleciClientDeleteEnvironmentVariableFromContextResponse{}, err
	}
	return result, nil
}

// DeleteScheduleByID - Deletes the schedule by id.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// scheduleID - The unique ID of the schedule.
// options - CircleciClientDeleteScheduleByIDOptions contains the optional parameters for the CircleciClient.DeleteScheduleByID
// method.
func (client *CircleciClient) DeleteScheduleByID(ctx context.Context, scheduleID string, options *CircleciClientDeleteScheduleByIDOptions) (CircleciClientDeleteScheduleByIDResponse, error) {
	req, err := client.deleteScheduleByIDCreateRequest(ctx, scheduleID, options)
	if err != nil {
		return CircleciClientDeleteScheduleByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientDeleteScheduleByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientDeleteScheduleByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteScheduleByIDHandleResponse(resp)
}

// deleteScheduleByIDCreateRequest creates the DeleteScheduleByID request.
func (client *CircleciClient) deleteScheduleByIDCreateRequest(ctx context.Context, scheduleID string, options *CircleciClientDeleteScheduleByIDOptions) (*policy.Request, error) {
	urlPath := "/schedule/{schedule-id}"
	urlPath = strings.ReplaceAll(urlPath, "{schedule-id}", url.PathEscape(scheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteScheduleByIDHandleResponse handles the DeleteScheduleByID response.
func (client *CircleciClient) deleteScheduleByIDHandleResponse(resp *http.Response) (CircleciClientDeleteScheduleByIDResponse, error) {
	result := CircleciClientDeleteScheduleByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MessageResponse6); err != nil {
		return CircleciClientDeleteScheduleByIDResponse{}, err
	}
	return result, nil
}

// GetAllInsightsBranches - Get a list of all branches for a specified project. The list will only contain branches currently
// available within Insights.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetAllInsightsBranchesOptions contains the optional parameters for the CircleciClient.GetAllInsightsBranches
// method.
func (client *CircleciClient) GetAllInsightsBranches(ctx context.Context, projectSlug string, options *CircleciClientGetAllInsightsBranchesOptions) (CircleciClientGetAllInsightsBranchesResponse, error) {
	req, err := client.getAllInsightsBranchesCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetAllInsightsBranchesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetAllInsightsBranchesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetAllInsightsBranchesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAllInsightsBranchesHandleResponse(resp)
}

// getAllInsightsBranchesCreateRequest creates the GetAllInsightsBranches request.
func (client *CircleciClient) getAllInsightsBranchesCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetAllInsightsBranchesOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/branches"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.WorkflowName != nil {
		reqQP.Set("workflow-name", *options.WorkflowName)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAllInsightsBranchesHandleResponse handles the GetAllInsightsBranches response.
func (client *CircleciClient) getAllInsightsBranchesHandleResponse(resp *http.Response) (CircleciClientGetAllInsightsBranchesResponse, error) {
	result := CircleciClientGetAllInsightsBranchesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return CircleciClientGetAllInsightsBranchesResponse{}, err
	}
	return result, nil
}

// GetCheckoutKey - Returns an individual checkout key.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// fingerprint - An SSH key fingerprint.
// options - CircleciClientGetCheckoutKeyOptions contains the optional parameters for the CircleciClient.GetCheckoutKey method.
func (client *CircleciClient) GetCheckoutKey(ctx context.Context, projectSlug string, fingerprint string, options *CircleciClientGetCheckoutKeyOptions) (CircleciClientGetCheckoutKeyResponse, error) {
	req, err := client.getCheckoutKeyCreateRequest(ctx, projectSlug, fingerprint, options)
	if err != nil {
		return CircleciClientGetCheckoutKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetCheckoutKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetCheckoutKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCheckoutKeyHandleResponse(resp)
}

// getCheckoutKeyCreateRequest creates the GetCheckoutKey request.
func (client *CircleciClient) getCheckoutKeyCreateRequest(ctx context.Context, projectSlug string, fingerprint string, options *CircleciClientGetCheckoutKeyOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/checkout-key/{fingerprint}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if fingerprint == "" {
		return nil, errors.New("parameter fingerprint cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fingerprint}", url.PathEscape(fingerprint))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCheckoutKeyHandleResponse handles the GetCheckoutKey response.
func (client *CircleciClient) getCheckoutKeyHandleResponse(resp *http.Response) (CircleciClientGetCheckoutKeyResponse, error) {
	result := CircleciClientGetCheckoutKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckoutKey0); err != nil {
		return CircleciClientGetCheckoutKeyResponse{}, err
	}
	return result, nil
}

// GetCollaborations - Provides the set of organizations of which a user is a member or a collaborator.
// The set of organizations that a user can collaborate on is composed of:
// * Organizations that the current user belongs to across VCS types (e.g. BitBucket, GitHub)
// * The parent organization of repository that the user can collaborate on, but is not necessarily a member of
// * The organization of the current user's account
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientGetCollaborationsOptions contains the optional parameters for the CircleciClient.GetCollaborations
// method.
func (client *CircleciClient) GetCollaborations(ctx context.Context, options *CircleciClientGetCollaborationsOptions) (CircleciClientGetCollaborationsResponse, error) {
	req, err := client.getCollaborationsCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientGetCollaborationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetCollaborationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetCollaborationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCollaborationsHandleResponse(resp)
}

// getCollaborationsCreateRequest creates the GetCollaborations request.
func (client *CircleciClient) getCollaborationsCreateRequest(ctx context.Context, options *CircleciClientGetCollaborationsOptions) (*policy.Request, error) {
	urlPath := "/me/collaborations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCollaborationsHandleResponse handles the GetCollaborations response.
func (client *CircleciClient) getCollaborationsHandleResponse(resp *http.Response) (CircleciClientGetCollaborationsResponse, error) {
	result := CircleciClientGetCollaborationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Get200ApplicationJSONItemsItemArray); err != nil {
		return CircleciClientGetCollaborationsResponse{}, err
	}
	return result, nil
}

// GetContext - Returns basic information about a context.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// contextID - ID of the context (UUID)
// options - CircleciClientGetContextOptions contains the optional parameters for the CircleciClient.GetContext method.
func (client *CircleciClient) GetContext(ctx context.Context, contextID string, options *CircleciClientGetContextOptions) (CircleciClientGetContextResponse, error) {
	req, err := client.getContextCreateRequest(ctx, contextID, options)
	if err != nil {
		return CircleciClientGetContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.getContextHandleResponse(resp)
}

// getContextCreateRequest creates the GetContext request.
func (client *CircleciClient) getContextCreateRequest(ctx context.Context, contextID string, options *CircleciClientGetContextOptions) (*policy.Request, error) {
	urlPath := "/context/{context-id}"
	urlPath = strings.ReplaceAll(urlPath, "{context-id}", url.PathEscape(contextID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getContextHandleResponse handles the GetContext response.
func (client *CircleciClient) getContextHandleResponse(resp *http.Response) (CircleciClientGetContextResponse, error) {
	result := CircleciClientGetContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Context0); err != nil {
		return CircleciClientGetContextResponse{}, err
	}
	return result, nil
}

// GetCurrentUser - Provides information about the user that is currently signed in.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientGetCurrentUserOptions contains the optional parameters for the CircleciClient.GetCurrentUser method.
func (client *CircleciClient) GetCurrentUser(ctx context.Context, options *CircleciClientGetCurrentUserOptions) (CircleciClientGetCurrentUserResponse, error) {
	req, err := client.getCurrentUserCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientGetCurrentUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetCurrentUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetCurrentUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCurrentUserHandleResponse(resp)
}

// getCurrentUserCreateRequest creates the GetCurrentUser request.
func (client *CircleciClient) getCurrentUserCreateRequest(ctx context.Context, options *CircleciClientGetCurrentUserOptions) (*policy.Request, error) {
	urlPath := "/me"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getCurrentUserHandleResponse handles the GetCurrentUser response.
func (client *CircleciClient) getCurrentUserHandleResponse(resp *http.Response) (CircleciClientGetCurrentUserResponse, error) {
	result := CircleciClientGetCurrentUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User); err != nil {
		return CircleciClientGetCurrentUserResponse{}, err
	}
	return result, nil
}

// GetEnvVar - Returns the masked value of environment variable :name.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// name - The name of the environment variable.
// options - CircleciClientGetEnvVarOptions contains the optional parameters for the CircleciClient.GetEnvVar method.
func (client *CircleciClient) GetEnvVar(ctx context.Context, projectSlug string, name string, options *CircleciClientGetEnvVarOptions) (CircleciClientGetEnvVarResponse, error) {
	req, err := client.getEnvVarCreateRequest(ctx, projectSlug, name, options)
	if err != nil {
		return CircleciClientGetEnvVarResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetEnvVarResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetEnvVarResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEnvVarHandleResponse(resp)
}

// getEnvVarCreateRequest creates the GetEnvVar request.
func (client *CircleciClient) getEnvVarCreateRequest(ctx context.Context, projectSlug string, name string, options *CircleciClientGetEnvVarOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/envvar/{name}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getEnvVarHandleResponse handles the GetEnvVar response.
func (client *CircleciClient) getEnvVarHandleResponse(resp *http.Response) (CircleciClientGetEnvVarResponse, error) {
	result := CircleciClientGetEnvVarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentVariablePair1); err != nil {
		return CircleciClientGetEnvVarResponse{}, err
	}
	return result, nil
}

// GetFlakyTests - Get a list of flaky tests for a given project. Flaky tests are branch agnostic. A flaky test is a test
// that passed and faliled in the same commit.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetFlakyTestsOptions contains the optional parameters for the CircleciClient.GetFlakyTests method.
func (client *CircleciClient) GetFlakyTests(ctx context.Context, projectSlug string, options *CircleciClientGetFlakyTestsOptions) (CircleciClientGetFlakyTestsResponse, error) {
	req, err := client.getFlakyTestsCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetFlakyTestsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetFlakyTestsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetFlakyTestsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFlakyTestsHandleResponse(resp)
}

// getFlakyTestsCreateRequest creates the GetFlakyTests request.
func (client *CircleciClient) getFlakyTestsCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetFlakyTestsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/flaky-tests"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFlakyTestsHandleResponse handles the GetFlakyTests response.
func (client *CircleciClient) getFlakyTestsHandleResponse(resp *http.Response) (CircleciClientGetFlakyTestsResponse, error) {
	result := CircleciClientGetFlakyTestsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsFqa3Z9InsightsProjectSlugFlakyTestsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetFlakyTestsResponse{}, err
	}
	return result, nil
}

// GetJobArtifacts - Returns a job's artifacts.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// jobNumber - The number of the job.
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetJobArtifactsOptions contains the optional parameters for the CircleciClient.GetJobArtifacts
// method.
func (client *CircleciClient) GetJobArtifacts(ctx context.Context, jobNumber int32, projectSlug string, options *CircleciClientGetJobArtifactsOptions) (CircleciClientGetJobArtifactsResponse, error) {
	req, err := client.getJobArtifactsCreateRequest(ctx, jobNumber, projectSlug, options)
	if err != nil {
		return CircleciClientGetJobArtifactsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetJobArtifactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetJobArtifactsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getJobArtifactsHandleResponse(resp)
}

// getJobArtifactsCreateRequest creates the GetJobArtifacts request.
func (client *CircleciClient) getJobArtifactsCreateRequest(ctx context.Context, jobNumber int32, projectSlug string, options *CircleciClientGetJobArtifactsOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/{job-number}/artifacts"
	urlPath = strings.ReplaceAll(urlPath, "{job-number}", url.PathEscape(strconv.FormatInt(int64(jobNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getJobArtifactsHandleResponse handles the GetJobArtifacts response.
func (client *CircleciClient) getJobArtifactsHandleResponse(resp *http.Response) (CircleciClientGetJobArtifactsResponse, error) {
	result := CircleciClientGetJobArtifactsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactListResponse); err != nil {
		return CircleciClientGetJobArtifactsResponse{}, err
	}
	return result, nil
}

// GetJobDetails - Returns job details.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// jobNumber - The number of the job.
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetJobDetailsOptions contains the optional parameters for the CircleciClient.GetJobDetails method.
func (client *CircleciClient) GetJobDetails(ctx context.Context, jobNumber interface{}, projectSlug string, options *CircleciClientGetJobDetailsOptions) (CircleciClientGetJobDetailsResponse, error) {
	req, err := client.getJobDetailsCreateRequest(ctx, jobNumber, projectSlug, options)
	if err != nil {
		return CircleciClientGetJobDetailsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetJobDetailsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetJobDetailsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getJobDetailsHandleResponse(resp)
}

// getJobDetailsCreateRequest creates the GetJobDetails request.
func (client *CircleciClient) getJobDetailsCreateRequest(ctx context.Context, jobNumber interface{}, projectSlug string, options *CircleciClientGetJobDetailsOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/job/{job-number}"
	urlPath = strings.ReplaceAll(urlPath, "{job-number}", url.PathEscape(jobNumber))
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getJobDetailsHandleResponse handles the GetJobDetails response.
func (client *CircleciClient) getJobDetailsHandleResponse(resp *http.Response) (CircleciClientGetJobDetailsResponse, error) {
	result := CircleciClientGetJobDetailsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.JobDetails); err != nil {
		return CircleciClientGetJobDetailsResponse{}, err
	}
	return result, nil
}

// GetJobTimeseries - Get timeseries data for all jobs within a workflow.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// options - CircleciClientGetJobTimeseriesOptions contains the optional parameters for the CircleciClient.GetJobTimeseries
// method.
func (client *CircleciClient) GetJobTimeseries(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetJobTimeseriesOptions) (CircleciClientGetJobTimeseriesResponse, error) {
	req, err := client.getJobTimeseriesCreateRequest(ctx, projectSlug, workflowName, options)
	if err != nil {
		return CircleciClientGetJobTimeseriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetJobTimeseriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetJobTimeseriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getJobTimeseriesHandleResponse(resp)
}

// getJobTimeseriesCreateRequest creates the GetJobTimeseries request.
func (client *CircleciClient) getJobTimeseriesCreateRequest(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetJobTimeseriesOptions) (*policy.Request, error) {
	urlPath := "/insights/time-series/{project-slug}/workflows/{workflow-name}/jobs"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.TimeseriesGranularity != nil {
		reqQP.Set("timeseries-granularity", string(*options.TimeseriesGranularity))
	}
	if options != nil && options.StartDate != nil {
		reqQP.Set("start-date", options.StartDate.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndDate != nil {
		reqQP.Set("end-date", options.EndDate.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getJobTimeseriesHandleResponse handles the GetJobTimeseries response.
func (client *CircleciClient) getJobTimeseriesHandleResponse(resp *http.Response) (CircleciClientGetJobTimeseriesResponse, error) {
	result := CircleciClientGetJobTimeseriesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Yiabp7InsightsTimeSeriesProjectSlugWorkflowsWorkflowNameJobsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetJobTimeseriesResponse{}, err
	}
	return result, nil
}

// GetOrgSummaryData - Gets aggregated summary metrics with trends for the entire org. Also gets aggregated metrics and trends
// for each project belonging to the org.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// orgSlug - Org slug in the form vcs-slug/org-name. The / characters may be URL-escaped.
// options - CircleciClientGetOrgSummaryDataOptions contains the optional parameters for the CircleciClient.GetOrgSummaryData
// method.
func (client *CircleciClient) GetOrgSummaryData(ctx context.Context, orgSlug string, options *CircleciClientGetOrgSummaryDataOptions) (CircleciClientGetOrgSummaryDataResponse, error) {
	req, err := client.getOrgSummaryDataCreateRequest(ctx, orgSlug, options)
	if err != nil {
		return CircleciClientGetOrgSummaryDataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetOrgSummaryDataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetOrgSummaryDataResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrgSummaryDataHandleResponse(resp)
}

// getOrgSummaryDataCreateRequest creates the GetOrgSummaryData request.
func (client *CircleciClient) getOrgSummaryDataCreateRequest(ctx context.Context, orgSlug string, options *CircleciClientGetOrgSummaryDataOptions) (*policy.Request, error) {
	urlPath := "/insights/{org-slug}/summary"
	if orgSlug == "" {
		return nil, errors.New("parameter orgSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org-slug}", url.PathEscape(orgSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReportingWindow != nil {
		reqQP.Set("reporting-window", string(*options.ReportingWindow))
	}
	if options != nil && options.ProjectNames != nil {
		reqQP.Set("project-names", options.ProjectNames)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrgSummaryDataHandleResponse handles the GetOrgSummaryData response.
func (client *CircleciClient) getOrgSummaryDataHandleResponse(resp *http.Response) (CircleciClientGetOrgSummaryDataResponse, error) {
	result := CircleciClientGetOrgSummaryDataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths3Qw5G4InsightsOrgSlugSummaryGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetOrgSummaryDataResponse{}, err
	}
	return result, nil
}

// GetPipelineByID - Returns a pipeline by ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// pipelineID - The unique ID of the pipeline.
// options - CircleciClientGetPipelineByIDOptions contains the optional parameters for the CircleciClient.GetPipelineByID
// method.
func (client *CircleciClient) GetPipelineByID(ctx context.Context, pipelineID string, options *CircleciClientGetPipelineByIDOptions) (CircleciClientGetPipelineByIDResponse, error) {
	req, err := client.getPipelineByIDCreateRequest(ctx, pipelineID, options)
	if err != nil {
		return CircleciClientGetPipelineByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetPipelineByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetPipelineByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPipelineByIDHandleResponse(resp)
}

// getPipelineByIDCreateRequest creates the GetPipelineByID request.
func (client *CircleciClient) getPipelineByIDCreateRequest(ctx context.Context, pipelineID string, options *CircleciClientGetPipelineByIDOptions) (*policy.Request, error) {
	urlPath := "/pipeline/{pipeline-id}"
	urlPath = strings.ReplaceAll(urlPath, "{pipeline-id}", url.PathEscape(pipelineID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPipelineByIDHandleResponse handles the GetPipelineByID response.
func (client *CircleciClient) getPipelineByIDHandleResponse(resp *http.Response) (CircleciClientGetPipelineByIDResponse, error) {
	result := CircleciClientGetPipelineByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Pipeline); err != nil {
		return CircleciClientGetPipelineByIDResponse{}, err
	}
	return result, nil
}

// GetPipelineByNumber - Returns a pipeline by number.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// pipelineNumber - The number of the pipeline.
// options - CircleciClientGetPipelineByNumberOptions contains the optional parameters for the CircleciClient.GetPipelineByNumber
// method.
func (client *CircleciClient) GetPipelineByNumber(ctx context.Context, projectSlug string, pipelineNumber interface{}, options *CircleciClientGetPipelineByNumberOptions) (CircleciClientGetPipelineByNumberResponse, error) {
	req, err := client.getPipelineByNumberCreateRequest(ctx, projectSlug, pipelineNumber, options)
	if err != nil {
		return CircleciClientGetPipelineByNumberResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetPipelineByNumberResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetPipelineByNumberResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPipelineByNumberHandleResponse(resp)
}

// getPipelineByNumberCreateRequest creates the GetPipelineByNumber request.
func (client *CircleciClient) getPipelineByNumberCreateRequest(ctx context.Context, projectSlug string, pipelineNumber interface{}, options *CircleciClientGetPipelineByNumberOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/pipeline/{pipeline-number}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	urlPath = strings.ReplaceAll(urlPath, "{pipeline-number}", url.PathEscape(pipelineNumber))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPipelineByNumberHandleResponse handles the GetPipelineByNumber response.
func (client *CircleciClient) getPipelineByNumberHandleResponse(resp *http.Response) (CircleciClientGetPipelineByNumberResponse, error) {
	result := CircleciClientGetPipelineByNumberResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Pipeline0); err != nil {
		return CircleciClientGetPipelineByNumberResponse{}, err
	}
	return result, nil
}

// GetPipelineConfigByID - Returns a pipeline's configuration by ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// pipelineID - The unique ID of the pipeline.
// options - CircleciClientGetPipelineConfigByIDOptions contains the optional parameters for the CircleciClient.GetPipelineConfigByID
// method.
func (client *CircleciClient) GetPipelineConfigByID(ctx context.Context, pipelineID string, options *CircleciClientGetPipelineConfigByIDOptions) (CircleciClientGetPipelineConfigByIDResponse, error) {
	req, err := client.getPipelineConfigByIDCreateRequest(ctx, pipelineID, options)
	if err != nil {
		return CircleciClientGetPipelineConfigByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetPipelineConfigByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetPipelineConfigByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPipelineConfigByIDHandleResponse(resp)
}

// getPipelineConfigByIDCreateRequest creates the GetPipelineConfigByID request.
func (client *CircleciClient) getPipelineConfigByIDCreateRequest(ctx context.Context, pipelineID string, options *CircleciClientGetPipelineConfigByIDOptions) (*policy.Request, error) {
	urlPath := "/pipeline/{pipeline-id}/config"
	urlPath = strings.ReplaceAll(urlPath, "{pipeline-id}", url.PathEscape(pipelineID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPipelineConfigByIDHandleResponse handles the GetPipelineConfigByID response.
func (client *CircleciClient) getPipelineConfigByIDHandleResponse(resp *http.Response) (CircleciClientGetPipelineConfigByIDResponse, error) {
	result := CircleciClientGetPipelineConfigByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PipelineConfig); err != nil {
		return CircleciClientGetPipelineConfigByIDResponse{}, err
	}
	return result, nil
}

// GetProjectBySlug - Retrieves a project by project slug.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetProjectBySlugOptions contains the optional parameters for the CircleciClient.GetProjectBySlug
// method.
func (client *CircleciClient) GetProjectBySlug(ctx context.Context, projectSlug string, options *CircleciClientGetProjectBySlugOptions) (CircleciClientGetProjectBySlugResponse, error) {
	req, err := client.getProjectBySlugCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetProjectBySlugResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectBySlugResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectBySlugResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectBySlugHandleResponse(resp)
}

// getProjectBySlugCreateRequest creates the GetProjectBySlug request.
func (client *CircleciClient) getProjectBySlugCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetProjectBySlugOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectBySlugHandleResponse handles the GetProjectBySlug response.
func (client *CircleciClient) getProjectBySlugHandleResponse(resp *http.Response) (CircleciClientGetProjectBySlugResponse, error) {
	result := CircleciClientGetProjectBySlugResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Project); err != nil {
		return CircleciClientGetProjectBySlugResponse{}, err
	}
	return result, nil
}

// GetProjectJobRuns - Get recent runs of a job within a workflow. Runs going back at most 90 days are returned. Please note
// that Insights is not a real time financial reporting tool and should not be used for credit
// reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// jobName - The name of the job.
// options - CircleciClientGetProjectJobRunsOptions contains the optional parameters for the CircleciClient.GetProjectJobRuns
// method.
func (client *CircleciClient) GetProjectJobRuns(ctx context.Context, projectSlug string, workflowName string, jobName string, options *CircleciClientGetProjectJobRunsOptions) (CircleciClientGetProjectJobRunsResponse, error) {
	req, err := client.getProjectJobRunsCreateRequest(ctx, projectSlug, workflowName, jobName, options)
	if err != nil {
		return CircleciClientGetProjectJobRunsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectJobRunsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectJobRunsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectJobRunsHandleResponse(resp)
}

// getProjectJobRunsCreateRequest creates the GetProjectJobRuns request.
func (client *CircleciClient) getProjectJobRunsCreateRequest(ctx context.Context, projectSlug string, workflowName string, jobName string, options *CircleciClientGetProjectJobRunsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows/{workflow-name}/jobs/{job-name}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	if jobName == "" {
		return nil, errors.New("parameter jobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{job-name}", url.PathEscape(jobName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	if options != nil && options.StartDate != nil {
		reqQP.Set("start-date", options.StartDate.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndDate != nil {
		reqQP.Set("end-date", options.EndDate.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectJobRunsHandleResponse handles the GetProjectJobRuns response.
func (client *CircleciClient) getProjectJobRunsHandleResponse(resp *http.Response) (CircleciClientGetProjectJobRunsResponse, error) {
	result := CircleciClientGetProjectJobRunsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsX3FxmxInsightsProjectSlugWorkflowsWorkflowNameJobsJobNameGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectJobRunsResponse{}, err
	}
	return result, nil
}

// GetProjectWorkflowJobMetrics - Get summary metrics for a project workflow's jobs. Job runs going back at most 90 days are
// included in the aggregation window. Metrics are refreshed daily, and thus may not include executions from the
// last 24 hours. Please note that Insights is not a real time financial reporting tool and should not be used for credit
// reporting. The most up to date credit information can be found in Plan Overview
// in the CircleCI UI.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// options - CircleciClientGetProjectWorkflowJobMetricsOptions contains the optional parameters for the CircleciClient.GetProjectWorkflowJobMetrics
// method.
func (client *CircleciClient) GetProjectWorkflowJobMetrics(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowJobMetricsOptions) (CircleciClientGetProjectWorkflowJobMetricsResponse, error) {
	req, err := client.getProjectWorkflowJobMetricsCreateRequest(ctx, projectSlug, workflowName, options)
	if err != nil {
		return CircleciClientGetProjectWorkflowJobMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectWorkflowJobMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectWorkflowJobMetricsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectWorkflowJobMetricsHandleResponse(resp)
}

// getProjectWorkflowJobMetricsCreateRequest creates the GetProjectWorkflowJobMetrics request.
func (client *CircleciClient) getProjectWorkflowJobMetricsCreateRequest(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowJobMetricsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows/{workflow-name}/jobs"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.ReportingWindow != nil {
		reqQP.Set("reporting-window", string(*options.ReportingWindow))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectWorkflowJobMetricsHandleResponse handles the GetProjectWorkflowJobMetrics response.
func (client *CircleciClient) getProjectWorkflowJobMetricsHandleResponse(resp *http.Response) (CircleciClientGetProjectWorkflowJobMetricsResponse, error) {
	result := CircleciClientGetProjectWorkflowJobMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsXllw8WInsightsProjectSlugWorkflowsWorkflowNameJobsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectWorkflowJobMetricsResponse{}, err
	}
	return result, nil
}

// GetProjectWorkflowMetrics - Get summary metrics for a project's workflows. Workflow runs going back at most 90 days are
// included in the aggregation window. Metrics are refreshed daily, and thus may not include executions from
// the last 24 hours. Please note that Insights is not a real time financial reporting tool and should not be used for credit
// reporting. The most up to date credit information can be found in Plan
// Overview in the CircleCI UI.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetProjectWorkflowMetricsOptions contains the optional parameters for the CircleciClient.GetProjectWorkflowMetrics
// method.
func (client *CircleciClient) GetProjectWorkflowMetrics(ctx context.Context, projectSlug string, options *CircleciClientGetProjectWorkflowMetricsOptions) (CircleciClientGetProjectWorkflowMetricsResponse, error) {
	req, err := client.getProjectWorkflowMetricsCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetProjectWorkflowMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectWorkflowMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectWorkflowMetricsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectWorkflowMetricsHandleResponse(resp)
}

// getProjectWorkflowMetricsCreateRequest creates the GetProjectWorkflowMetrics request.
func (client *CircleciClient) getProjectWorkflowMetricsCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetProjectWorkflowMetricsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.ReportingWindow != nil {
		reqQP.Set("reporting-window", string(*options.ReportingWindow))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectWorkflowMetricsHandleResponse handles the GetProjectWorkflowMetrics response.
func (client *CircleciClient) getProjectWorkflowMetricsHandleResponse(resp *http.Response) (CircleciClientGetProjectWorkflowMetricsResponse, error) {
	result := CircleciClientGetProjectWorkflowMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsUxywyxInsightsProjectSlugWorkflowsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectWorkflowMetricsResponse{}, err
	}
	return result, nil
}

// GetProjectWorkflowRuns - Get recent runs of a workflow. Runs going back at most 90 days are returned. Please note that
// Insights is not a real time financial reporting tool and should not be used for credit reporting. The most
// up to date credit information can be found in Plan Overview in the CircleCI UI.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// options - CircleciClientGetProjectWorkflowRunsOptions contains the optional parameters for the CircleciClient.GetProjectWorkflowRuns
// method.
func (client *CircleciClient) GetProjectWorkflowRuns(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowRunsOptions) (CircleciClientGetProjectWorkflowRunsResponse, error) {
	req, err := client.getProjectWorkflowRunsCreateRequest(ctx, projectSlug, workflowName, options)
	if err != nil {
		return CircleciClientGetProjectWorkflowRunsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectWorkflowRunsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectWorkflowRunsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectWorkflowRunsHandleResponse(resp)
}

// getProjectWorkflowRunsCreateRequest creates the GetProjectWorkflowRuns request.
func (client *CircleciClient) getProjectWorkflowRunsCreateRequest(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowRunsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows/{workflow-name}"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	if options != nil && options.StartDate != nil {
		reqQP.Set("start-date", options.StartDate.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndDate != nil {
		reqQP.Set("end-date", options.EndDate.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectWorkflowRunsHandleResponse handles the GetProjectWorkflowRuns response.
func (client *CircleciClient) getProjectWorkflowRunsHandleResponse(resp *http.Response) (CircleciClientGetProjectWorkflowRunsResponse, error) {
	result := CircleciClientGetProjectWorkflowRunsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsRd9DcuInsightsProjectSlugWorkflowsWorkflowNameGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectWorkflowRunsResponse{}, err
	}
	return result, nil
}

// GetProjectWorkflowTestMetrics - Get test metrics for a project's workflows. Currently tests metrics are calculated based
// on 10 most recent workflow runs.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// options - CircleciClientGetProjectWorkflowTestMetricsOptions contains the optional parameters for the CircleciClient.GetProjectWorkflowTestMetrics
// method.
func (client *CircleciClient) GetProjectWorkflowTestMetrics(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowTestMetricsOptions) (CircleciClientGetProjectWorkflowTestMetricsResponse, error) {
	req, err := client.getProjectWorkflowTestMetricsCreateRequest(ctx, projectSlug, workflowName, options)
	if err != nil {
		return CircleciClientGetProjectWorkflowTestMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectWorkflowTestMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectWorkflowTestMetricsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectWorkflowTestMetricsHandleResponse(resp)
}

// getProjectWorkflowTestMetricsCreateRequest creates the GetProjectWorkflowTestMetrics request.
func (client *CircleciClient) getProjectWorkflowTestMetricsCreateRequest(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetProjectWorkflowTestMetricsOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows/{workflow-name}/test-metrics"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectWorkflowTestMetricsHandleResponse handles the GetProjectWorkflowTestMetrics response.
func (client *CircleciClient) getProjectWorkflowTestMetricsHandleResponse(resp *http.Response) (CircleciClientGetProjectWorkflowTestMetricsResponse, error) {
	result := CircleciClientGetProjectWorkflowTestMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths17Ss7PbInsightsProjectSlugWorkflowsWorkflowNameTestMetricsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectWorkflowTestMetricsResponse{}, err
	}
	return result, nil
}

// GetProjectWorkflowsPageData - Get summary metrics and trends for a project at workflow and branch level. Workflow runs
// going back at most 90 days are included in the aggregation window. Trends are only supported upto last 30 days.
// Metrics are refreshed daily, and thus may not include executions from the last 24 hours. Please note that Insights is not
// a real time financial reporting tool and should not be used for credit
// reporting. The most up to date credit information can be found in Plan Overview in the CircleCI UI.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetProjectWorkflowsPageDataOptions contains the optional parameters for the CircleciClient.GetProjectWorkflowsPageData
// method.
func (client *CircleciClient) GetProjectWorkflowsPageData(ctx context.Context, projectSlug string, options *CircleciClientGetProjectWorkflowsPageDataOptions) (CircleciClientGetProjectWorkflowsPageDataResponse, error) {
	req, err := client.getProjectWorkflowsPageDataCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetProjectWorkflowsPageDataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetProjectWorkflowsPageDataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetProjectWorkflowsPageDataResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectWorkflowsPageDataHandleResponse(resp)
}

// getProjectWorkflowsPageDataCreateRequest creates the GetProjectWorkflowsPageData request.
func (client *CircleciClient) getProjectWorkflowsPageDataCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetProjectWorkflowsPageDataOptions) (*policy.Request, error) {
	urlPath := "/insights/pages/{project-slug}/summary"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ReportingWindow != nil {
		reqQP.Set("reporting-window", string(*options.ReportingWindow))
	}
	if options != nil && options.Branches != nil {
		reqQP.Set("branches", options.Branches)
	}
	if options != nil && options.WorkflowNames != nil {
		reqQP.Set("workflow-names", options.WorkflowNames)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectWorkflowsPageDataHandleResponse handles the GetProjectWorkflowsPageData response.
func (client *CircleciClient) getProjectWorkflowsPageDataHandleResponse(resp *http.Response) (CircleciClientGetProjectWorkflowsPageDataResponse, error) {
	result := CircleciClientGetProjectWorkflowsPageDataResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsZsvny0InsightsPagesProjectSlugSummaryGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetProjectWorkflowsPageDataResponse{}, err
	}
	return result, nil
}

// GetScheduleByID - Get a schedule by id.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// scheduleID - The unique ID of the schedule.
// options - CircleciClientGetScheduleByIDOptions contains the optional parameters for the CircleciClient.GetScheduleByID
// method.
func (client *CircleciClient) GetScheduleByID(ctx context.Context, scheduleID string, options *CircleciClientGetScheduleByIDOptions) (CircleciClientGetScheduleByIDResponse, error) {
	req, err := client.getScheduleByIDCreateRequest(ctx, scheduleID, options)
	if err != nil {
		return CircleciClientGetScheduleByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetScheduleByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetScheduleByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.getScheduleByIDHandleResponse(resp)
}

// getScheduleByIDCreateRequest creates the GetScheduleByID request.
func (client *CircleciClient) getScheduleByIDCreateRequest(ctx context.Context, scheduleID string, options *CircleciClientGetScheduleByIDOptions) (*policy.Request, error) {
	urlPath := "/schedule/{schedule-id}"
	urlPath = strings.ReplaceAll(urlPath, "{schedule-id}", url.PathEscape(scheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getScheduleByIDHandleResponse handles the GetScheduleByID response.
func (client *CircleciClient) getScheduleByIDHandleResponse(resp *http.Response) (CircleciClientGetScheduleByIDResponse, error) {
	result := CircleciClientGetScheduleByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Schedule0); err != nil {
		return CircleciClientGetScheduleByIDResponse{}, err
	}
	return result, nil
}

// GetTests - Get test metadata for a build. In the rare case where there is more than 250MB of test data on the job, no results
// will be returned.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// jobNumber - The number of the job.
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetTestsOptions contains the optional parameters for the CircleciClient.GetTests method.
func (client *CircleciClient) GetTests(ctx context.Context, jobNumber interface{}, projectSlug string, options *CircleciClientGetTestsOptions) (CircleciClientGetTestsResponse, error) {
	req, err := client.getTestsCreateRequest(ctx, jobNumber, projectSlug, options)
	if err != nil {
		return CircleciClientGetTestsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetTestsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetTestsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTestsHandleResponse(resp)
}

// getTestsCreateRequest creates the GetTests request.
func (client *CircleciClient) getTestsCreateRequest(ctx context.Context, jobNumber interface{}, projectSlug string, options *CircleciClientGetTestsOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/{job-number}/tests"
	urlPath = strings.ReplaceAll(urlPath, "{job-number}", url.PathEscape(jobNumber))
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTestsHandleResponse handles the GetTests response.
func (client *CircleciClient) getTestsHandleResponse(resp *http.Response) (CircleciClientGetTestsResponse, error) {
	result := CircleciClientGetTestsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TestsResponse); err != nil {
		return CircleciClientGetTestsResponse{}, err
	}
	return result, nil
}

// GetUser - Provides information about the user with the given ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// id - The unique ID of the user.
// options - CircleciClientGetUserOptions contains the optional parameters for the CircleciClient.GetUser method.
func (client *CircleciClient) GetUser(ctx context.Context, id string, options *CircleciClientGetUserOptions) (CircleciClientGetUserResponse, error) {
	req, err := client.getUserCreateRequest(ctx, id, options)
	if err != nil {
		return CircleciClientGetUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUserHandleResponse(resp)
}

// getUserCreateRequest creates the GetUser request.
func (client *CircleciClient) getUserCreateRequest(ctx context.Context, id string, options *CircleciClientGetUserOptions) (*policy.Request, error) {
	urlPath := "/user/{id}"
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserHandleResponse handles the GetUser response.
func (client *CircleciClient) getUserHandleResponse(resp *http.Response) (CircleciClientGetUserResponse, error) {
	result := CircleciClientGetUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.User0); err != nil {
		return CircleciClientGetUserResponse{}, err
	}
	return result, nil
}

// GetWorkflowByID - Returns summary fields of a workflow by ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// id - The unique ID of the workflow.
// options - CircleciClientGetWorkflowByIDOptions contains the optional parameters for the CircleciClient.GetWorkflowByID
// method.
func (client *CircleciClient) GetWorkflowByID(ctx context.Context, id string, options *CircleciClientGetWorkflowByIDOptions) (CircleciClientGetWorkflowByIDResponse, error) {
	req, err := client.getWorkflowByIDCreateRequest(ctx, id, options)
	if err != nil {
		return CircleciClientGetWorkflowByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetWorkflowByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetWorkflowByIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWorkflowByIDHandleResponse(resp)
}

// getWorkflowByIDCreateRequest creates the GetWorkflowByID request.
func (client *CircleciClient) getWorkflowByIDCreateRequest(ctx context.Context, id string, options *CircleciClientGetWorkflowByIDOptions) (*policy.Request, error) {
	urlPath := "/workflow/{id}"
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWorkflowByIDHandleResponse handles the GetWorkflowByID response.
func (client *CircleciClient) getWorkflowByIDHandleResponse(resp *http.Response) (CircleciClientGetWorkflowByIDResponse, error) {
	result := CircleciClientGetWorkflowByIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Workflow); err != nil {
		return CircleciClientGetWorkflowByIDResponse{}, err
	}
	return result, nil
}

// GetWorkflowSummary - Get the metrics and trends for a particular workflow on a single branch or all branches
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// workflowName - The name of the workflow.
// options - CircleciClientGetWorkflowSummaryOptions contains the optional parameters for the CircleciClient.GetWorkflowSummary
// method.
func (client *CircleciClient) GetWorkflowSummary(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetWorkflowSummaryOptions) (CircleciClientGetWorkflowSummaryResponse, error) {
	req, err := client.getWorkflowSummaryCreateRequest(ctx, projectSlug, workflowName, options)
	if err != nil {
		return CircleciClientGetWorkflowSummaryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetWorkflowSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetWorkflowSummaryResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWorkflowSummaryHandleResponse(resp)
}

// getWorkflowSummaryCreateRequest creates the GetWorkflowSummary request.
func (client *CircleciClient) getWorkflowSummaryCreateRequest(ctx context.Context, projectSlug string, workflowName string, options *CircleciClientGetWorkflowSummaryOptions) (*policy.Request, error) {
	urlPath := "/insights/{project-slug}/workflows/{workflow-name}/summary"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	if workflowName == "" {
		return nil, errors.New("parameter workflowName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workflow-name}", url.PathEscape(workflowName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	if options != nil && options.Branches != nil {
		reqQP.Set("branches", options.Branches)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWorkflowSummaryHandleResponse handles the GetWorkflowSummary response.
func (client *CircleciClient) getWorkflowSummaryHandleResponse(resp *http.Response) (CircleciClientGetWorkflowSummaryResponse, error) {
	result := CircleciClientGetWorkflowSummaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsSlfcapInsightsProjectSlugWorkflowsWorkflowNameSummaryGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetWorkflowSummaryResponse{}, err
	}
	return result, nil
}

// GetWorkflowTimeseries - If no query parameters are supplied, will return timeseries data for all workflows that have ran
// on the default branch.
// When granularity is `hourly`, up to 48 hours of timeseries data will be returned. When granularity is `daily`, up to 90
// days of timeseries data will be returned.
// Different combinations of branches and workflow-names can narrow the query further:
// * All workflows, default branch (default, no query parameters)
// * All workflows, all branches: `all-branches=true`
// * All workflows on specific branch: `branch=feature-branch`
// * A specified workflow, all branches: `workflow-name=build&all-branches=true`,
// * A specified branch on a specified workflow: `workflow-name=build&branch=feature-branch`
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientGetWorkflowTimeseriesOptions contains the optional parameters for the CircleciClient.GetWorkflowTimeseries
// method.
func (client *CircleciClient) GetWorkflowTimeseries(ctx context.Context, projectSlug string, options *CircleciClientGetWorkflowTimeseriesOptions) (CircleciClientGetWorkflowTimeseriesResponse, error) {
	req, err := client.getWorkflowTimeseriesCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientGetWorkflowTimeseriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientGetWorkflowTimeseriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientGetWorkflowTimeseriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWorkflowTimeseriesHandleResponse(resp)
}

// getWorkflowTimeseriesCreateRequest creates the GetWorkflowTimeseries request.
func (client *CircleciClient) getWorkflowTimeseriesCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientGetWorkflowTimeseriesOptions) (*policy.Request, error) {
	urlPath := "/insights/time-series/{project-slug}/workflows"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.AllBranches != nil {
		reqQP.Set("all-branches", strconv.FormatBool(*options.AllBranches))
	}
	if options != nil && options.TimeseriesGranularity != nil {
		reqQP.Set("timeseries-granularity", string(*options.TimeseriesGranularity))
	}
	if options != nil && options.WorkflowName != nil {
		reqQP.Set("workflow-name", *options.WorkflowName)
	}
	if options != nil && options.StartDate != nil {
		reqQP.Set("start-date", options.StartDate.Format(time.RFC3339Nano))
	}
	if options != nil && options.EndDate != nil {
		reqQP.Set("end-date", options.EndDate.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWorkflowTimeseriesHandleResponse handles the GetWorkflowTimeseries response.
func (client *CircleciClient) getWorkflowTimeseriesHandleResponse(resp *http.Response) (CircleciClientGetWorkflowTimeseriesResponse, error) {
	result := CircleciClientGetWorkflowTimeseriesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1OqdqwuInsightsTimeSeriesProjectSlugWorkflowsGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientGetWorkflowTimeseriesResponse{}, err
	}
	return result, nil
}

// ListCheckoutKeys - Returns a sequence of checkout keys for :project.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientListCheckoutKeysOptions contains the optional parameters for the CircleciClient.ListCheckoutKeys
// method.
func (client *CircleciClient) ListCheckoutKeys(ctx context.Context, projectSlug string, options *CircleciClientListCheckoutKeysOptions) (CircleciClientListCheckoutKeysResponse, error) {
	req, err := client.listCheckoutKeysCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientListCheckoutKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListCheckoutKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListCheckoutKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.listCheckoutKeysHandleResponse(resp)
}

// listCheckoutKeysCreateRequest creates the ListCheckoutKeys request.
func (client *CircleciClient) listCheckoutKeysCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientListCheckoutKeysOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/checkout-key"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listCheckoutKeysHandleResponse handles the ListCheckoutKeys response.
func (client *CircleciClient) listCheckoutKeysHandleResponse(resp *http.Response) (CircleciClientListCheckoutKeysResponse, error) {
	result := CircleciClientListCheckoutKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckoutKeyListResponse); err != nil {
		return CircleciClientListCheckoutKeysResponse{}, err
	}
	return result, nil
}

// ListContexts - List all contexts for an owner.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientListContextsOptions contains the optional parameters for the CircleciClient.ListContexts method.
func (client *CircleciClient) ListContexts(ctx context.Context, options *CircleciClientListContextsOptions) (CircleciClientListContextsResponse, error) {
	req, err := client.listContextsCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientListContextsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListContextsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListContextsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listContextsHandleResponse(resp)
}

// listContextsCreateRequest creates the ListContexts request.
func (client *CircleciClient) listContextsCreateRequest(ctx context.Context, options *CircleciClientListContextsOptions) (*policy.Request, error) {
	urlPath := "/context"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.OwnerID != nil {
		reqQP.Set("owner-id", *options.OwnerID)
	}
	if options != nil && options.OwnerSlug != nil {
		reqQP.Set("owner-slug", *options.OwnerSlug)
	}
	if options != nil && options.OwnerType != nil {
		reqQP.Set("owner-type", string(*options.OwnerType))
	}
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listContextsHandleResponse handles the ListContexts response.
func (client *CircleciClient) listContextsHandleResponse(resp *http.Response) (CircleciClientListContextsResponse, error) {
	result := CircleciClientListContextsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsXxgky4ContextGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientListContextsResponse{}, err
	}
	return result, nil
}

// ListEnvVars - Returns four 'x' characters, in addition to the last four ASCII characters of the value, consistent with
// the display of environment variable values on the CircleCI website.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientListEnvVarsOptions contains the optional parameters for the CircleciClient.ListEnvVars method.
func (client *CircleciClient) ListEnvVars(ctx context.Context, projectSlug string, options *CircleciClientListEnvVarsOptions) (CircleciClientListEnvVarsResponse, error) {
	req, err := client.listEnvVarsCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientListEnvVarsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListEnvVarsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListEnvVarsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listEnvVarsHandleResponse(resp)
}

// listEnvVarsCreateRequest creates the ListEnvVars request.
func (client *CircleciClient) listEnvVarsCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientListEnvVarsOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/envvar"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listEnvVarsHandleResponse handles the ListEnvVars response.
func (client *CircleciClient) listEnvVarsHandleResponse(resp *http.Response) (CircleciClientListEnvVarsResponse, error) {
	result := CircleciClientListEnvVarsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentVariableListResponse); err != nil {
		return CircleciClientListEnvVarsResponse{}, err
	}
	return result, nil
}

// ListEnvironmentVariablesFromContext - List information about environment variables in a context, not including their values.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// contextID - ID of the context (UUID)
// options - CircleciClientListEnvironmentVariablesFromContextOptions contains the optional parameters for the CircleciClient.ListEnvironmentVariablesFromContext
// method.
func (client *CircleciClient) ListEnvironmentVariablesFromContext(ctx context.Context, contextID string, options *CircleciClientListEnvironmentVariablesFromContextOptions) (CircleciClientListEnvironmentVariablesFromContextResponse, error) {
	req, err := client.listEnvironmentVariablesFromContextCreateRequest(ctx, contextID, options)
	if err != nil {
		return CircleciClientListEnvironmentVariablesFromContextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListEnvironmentVariablesFromContextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListEnvironmentVariablesFromContextResponse{}, runtime.NewResponseError(resp)
	}
	return client.listEnvironmentVariablesFromContextHandleResponse(resp)
}

// listEnvironmentVariablesFromContextCreateRequest creates the ListEnvironmentVariablesFromContext request.
func (client *CircleciClient) listEnvironmentVariablesFromContextCreateRequest(ctx context.Context, contextID string, options *CircleciClientListEnvironmentVariablesFromContextOptions) (*policy.Request, error) {
	urlPath := "/context/{context-id}/environment-variable"
	urlPath = strings.ReplaceAll(urlPath, "{context-id}", url.PathEscape(contextID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listEnvironmentVariablesFromContextHandleResponse handles the ListEnvironmentVariablesFromContext response.
func (client *CircleciClient) listEnvironmentVariablesFromContextHandleResponse(resp *http.Response) (CircleciClientListEnvironmentVariablesFromContextResponse, error) {
	result := CircleciClientListEnvironmentVariablesFromContextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1S7LurdContextIDEnvironmentVariableGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientListEnvironmentVariablesFromContextResponse{}, err
	}
	return result, nil
}

// ListMyPipelines - Returns a sequence of all pipelines for this project triggered by the user.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientListMyPipelinesOptions contains the optional parameters for the CircleciClient.ListMyPipelines
// method.
func (client *CircleciClient) ListMyPipelines(ctx context.Context, projectSlug string, options *CircleciClientListMyPipelinesOptions) (CircleciClientListMyPipelinesResponse, error) {
	req, err := client.listMyPipelinesCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientListMyPipelinesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListMyPipelinesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListMyPipelinesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listMyPipelinesHandleResponse(resp)
}

// listMyPipelinesCreateRequest creates the ListMyPipelines request.
func (client *CircleciClient) listMyPipelinesCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientListMyPipelinesOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/pipeline/mine"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMyPipelinesHandleResponse handles the ListMyPipelines response.
func (client *CircleciClient) listMyPipelinesHandleResponse(resp *http.Response) (CircleciClientListMyPipelinesResponse, error) {
	result := CircleciClientListMyPipelinesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PipelineListResponse1); err != nil {
		return CircleciClientListMyPipelinesResponse{}, err
	}
	return result, nil
}

// ListPipelines - Returns all pipelines for the most recently built projects (max 250) you follow in an organization.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// options - CircleciClientListPipelinesOptions contains the optional parameters for the CircleciClient.ListPipelines method.
func (client *CircleciClient) ListPipelines(ctx context.Context, options *CircleciClientListPipelinesOptions) (CircleciClientListPipelinesResponse, error) {
	req, err := client.listPipelinesCreateRequest(ctx, options)
	if err != nil {
		return CircleciClientListPipelinesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListPipelinesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListPipelinesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listPipelinesHandleResponse(resp)
}

// listPipelinesCreateRequest creates the ListPipelines request.
func (client *CircleciClient) listPipelinesCreateRequest(ctx context.Context, options *CircleciClientListPipelinesOptions) (*policy.Request, error) {
	urlPath := "/pipeline"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.OrgSlug != nil {
		reqQP.Set("org-slug", *options.OrgSlug)
	}
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	if options != nil && options.Mine != nil {
		reqQP.Set("mine", strconv.FormatBool(*options.Mine))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPipelinesHandleResponse handles the ListPipelines response.
func (client *CircleciClient) listPipelinesHandleResponse(resp *http.Response) (CircleciClientListPipelinesResponse, error) {
	result := CircleciClientListPipelinesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PipelineListResponse); err != nil {
		return CircleciClientListPipelinesResponse{}, err
	}
	return result, nil
}

// ListPipelinesForProject - Returns all pipelines for this project.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientListPipelinesForProjectOptions contains the optional parameters for the CircleciClient.ListPipelinesForProject
// method.
func (client *CircleciClient) ListPipelinesForProject(ctx context.Context, projectSlug string, options *CircleciClientListPipelinesForProjectOptions) (CircleciClientListPipelinesForProjectResponse, error) {
	req, err := client.listPipelinesForProjectCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientListPipelinesForProjectResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListPipelinesForProjectResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListPipelinesForProjectResponse{}, runtime.NewResponseError(resp)
	}
	return client.listPipelinesForProjectHandleResponse(resp)
}

// listPipelinesForProjectCreateRequest creates the ListPipelinesForProject request.
func (client *CircleciClient) listPipelinesForProjectCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientListPipelinesForProjectOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/pipeline"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Branch != nil {
		reqQP.Set("branch", *options.Branch)
	}
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPipelinesForProjectHandleResponse handles the ListPipelinesForProject response.
func (client *CircleciClient) listPipelinesForProjectHandleResponse(resp *http.Response) (CircleciClientListPipelinesForProjectResponse, error) {
	result := CircleciClientListPipelinesForProjectResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PipelineListResponse0); err != nil {
		return CircleciClientListPipelinesForProjectResponse{}, err
	}
	return result, nil
}

// ListSchedulesForProject - Returns all schedules for this project.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientListSchedulesForProjectOptions contains the optional parameters for the CircleciClient.ListSchedulesForProject
// method.
func (client *CircleciClient) ListSchedulesForProject(ctx context.Context, projectSlug string, options *CircleciClientListSchedulesForProjectOptions) (CircleciClientListSchedulesForProjectResponse, error) {
	req, err := client.listSchedulesForProjectCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientListSchedulesForProjectResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListSchedulesForProjectResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListSchedulesForProjectResponse{}, runtime.NewResponseError(resp)
	}
	return client.listSchedulesForProjectHandleResponse(resp)
}

// listSchedulesForProjectCreateRequest creates the ListSchedulesForProject request.
func (client *CircleciClient) listSchedulesForProjectCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientListSchedulesForProjectOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/schedule"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSchedulesForProjectHandleResponse handles the ListSchedulesForProject response.
func (client *CircleciClient) listSchedulesForProjectHandleResponse(resp *http.Response) (CircleciClientListSchedulesForProjectResponse, error) {
	result := CircleciClientListSchedulesForProjectResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsOvr64LProjectSlugScheduleGetResponses200ContentApplicationJSONSchema); err != nil {
		return CircleciClientListSchedulesForProjectResponse{}, err
	}
	return result, nil
}

// ListWorkflowJobs - Returns a sequence of jobs for a workflow.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// id - The unique ID of the workflow.
// options - CircleciClientListWorkflowJobsOptions contains the optional parameters for the CircleciClient.ListWorkflowJobs
// method.
func (client *CircleciClient) ListWorkflowJobs(ctx context.Context, id string, options *CircleciClientListWorkflowJobsOptions) (CircleciClientListWorkflowJobsResponse, error) {
	req, err := client.listWorkflowJobsCreateRequest(ctx, id, options)
	if err != nil {
		return CircleciClientListWorkflowJobsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListWorkflowJobsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListWorkflowJobsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listWorkflowJobsHandleResponse(resp)
}

// listWorkflowJobsCreateRequest creates the ListWorkflowJobs request.
func (client *CircleciClient) listWorkflowJobsCreateRequest(ctx context.Context, id string, options *CircleciClientListWorkflowJobsOptions) (*policy.Request, error) {
	urlPath := "/workflow/{id}/job"
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkflowJobsHandleResponse handles the ListWorkflowJobs response.
func (client *CircleciClient) listWorkflowJobsHandleResponse(resp *http.Response) (CircleciClientListWorkflowJobsResponse, error) {
	result := CircleciClientListWorkflowJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowJobListResponse); err != nil {
		return CircleciClientListWorkflowJobsResponse{}, err
	}
	return result, nil
}

// ListWorkflowsByPipelineID - Returns a paginated list of workflows by pipeline ID.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// pipelineID - The unique ID of the pipeline.
// options - CircleciClientListWorkflowsByPipelineIDOptions contains the optional parameters for the CircleciClient.ListWorkflowsByPipelineID
// method.
func (client *CircleciClient) ListWorkflowsByPipelineID(ctx context.Context, pipelineID string, options *CircleciClientListWorkflowsByPipelineIDOptions) (CircleciClientListWorkflowsByPipelineIDResponse, error) {
	req, err := client.listWorkflowsByPipelineIDCreateRequest(ctx, pipelineID, options)
	if err != nil {
		return CircleciClientListWorkflowsByPipelineIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientListWorkflowsByPipelineIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientListWorkflowsByPipelineIDResponse{}, runtime.NewResponseError(resp)
	}
	return client.listWorkflowsByPipelineIDHandleResponse(resp)
}

// listWorkflowsByPipelineIDCreateRequest creates the ListWorkflowsByPipelineID request.
func (client *CircleciClient) listWorkflowsByPipelineIDCreateRequest(ctx context.Context, pipelineID string, options *CircleciClientListWorkflowsByPipelineIDOptions) (*policy.Request, error) {
	urlPath := "/pipeline/{pipeline-id}/workflow"
	urlPath = strings.ReplaceAll(urlPath, "{pipeline-id}", url.PathEscape(pipelineID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.PageToken != nil {
		reqQP.Set("page-token", *options.PageToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWorkflowsByPipelineIDHandleResponse handles the ListWorkflowsByPipelineID response.
func (client *CircleciClient) listWorkflowsByPipelineIDHandleResponse(resp *http.Response) (CircleciClientListWorkflowsByPipelineIDResponse, error) {
	result := CircleciClientListWorkflowsByPipelineIDResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowListResponse); err != nil {
		return CircleciClientListWorkflowsByPipelineIDResponse{}, err
	}
	return result, nil
}

// RerunWorkflow - Reruns a workflow.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// id - The unique ID of the workflow.
// options - CircleciClientRerunWorkflowOptions contains the optional parameters for the CircleciClient.RerunWorkflow method.
func (client *CircleciClient) RerunWorkflow(ctx context.Context, id string, options *CircleciClientRerunWorkflowOptions) (CircleciClientRerunWorkflowResponse, error) {
	req, err := client.rerunWorkflowCreateRequest(ctx, id, options)
	if err != nil {
		return CircleciClientRerunWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientRerunWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return CircleciClientRerunWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.rerunWorkflowHandleResponse(resp)
}

// rerunWorkflowCreateRequest creates the RerunWorkflow request.
func (client *CircleciClient) rerunWorkflowCreateRequest(ctx context.Context, id string, options *CircleciClientRerunWorkflowOptions) (*policy.Request, error) {
	urlPath := "/workflow/{id}/rerun"
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// rerunWorkflowHandleResponse handles the RerunWorkflow response.
func (client *CircleciClient) rerunWorkflowHandleResponse(resp *http.Response) (CircleciClientRerunWorkflowResponse, error) {
	result := CircleciClientRerunWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsOtgng0WorkflowIDRerunPostResponses202ContentApplicationJSONSchema); err != nil {
		return CircleciClientRerunWorkflowResponse{}, err
	}
	return result, nil
}

// TriggerPipeline - Triggers a new pipeline on the project.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// projectSlug - Project slug in the form vcs-slug/org-name/repo-name. The / characters may be URL-escaped.
// options - CircleciClientTriggerPipelineOptions contains the optional parameters for the CircleciClient.TriggerPipeline
// method.
func (client *CircleciClient) TriggerPipeline(ctx context.Context, projectSlug string, options *CircleciClientTriggerPipelineOptions) (CircleciClientTriggerPipelineResponse, error) {
	req, err := client.triggerPipelineCreateRequest(ctx, projectSlug, options)
	if err != nil {
		return CircleciClientTriggerPipelineResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientTriggerPipelineResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return CircleciClientTriggerPipelineResponse{}, runtime.NewResponseError(resp)
	}
	return client.triggerPipelineHandleResponse(resp)
}

// triggerPipelineCreateRequest creates the TriggerPipeline request.
func (client *CircleciClient) triggerPipelineCreateRequest(ctx context.Context, projectSlug string, options *CircleciClientTriggerPipelineOptions) (*policy.Request, error) {
	urlPath := "/project/{project-slug}/pipeline"
	urlPath = strings.ReplaceAll(urlPath, "{project-slug}", projectSlug)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// triggerPipelineHandleResponse handles the TriggerPipeline response.
func (client *CircleciClient) triggerPipelineHandleResponse(resp *http.Response) (CircleciClientTriggerPipelineResponse, error) {
	result := CircleciClientTriggerPipelineResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PipelineCreation); err != nil {
		return CircleciClientTriggerPipelineResponse{}, err
	}
	return result, nil
}

// UpdateSchedule - Updates a schedule and returns the updated schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version v2
// scheduleID - The unique ID of the schedule.
// options - CircleciClientUpdateScheduleOptions contains the optional parameters for the CircleciClient.UpdateSchedule method.
func (client *CircleciClient) UpdateSchedule(ctx context.Context, scheduleID string, options *CircleciClientUpdateScheduleOptions) (CircleciClientUpdateScheduleResponse, error) {
	req, err := client.updateScheduleCreateRequest(ctx, scheduleID, options)
	if err != nil {
		return CircleciClientUpdateScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return CircleciClientUpdateScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return CircleciClientUpdateScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateScheduleHandleResponse(resp)
}

// updateScheduleCreateRequest creates the UpdateSchedule request.
func (client *CircleciClient) updateScheduleCreateRequest(ctx context.Context, scheduleID string, options *CircleciClientUpdateScheduleOptions) (*policy.Request, error) {
	urlPath := "/schedule/{schedule-id}"
	urlPath = strings.ReplaceAll(urlPath, "{schedule-id}", url.PathEscape(scheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateScheduleHandleResponse handles the UpdateSchedule response.
func (client *CircleciClient) updateScheduleHandleResponse(resp *http.Response) (CircleciClientUpdateScheduleResponse, error) {
	result := CircleciClientUpdateScheduleResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Schedule1); err != nil {
		return CircleciClientUpdateScheduleResponse{}, err
	}
	return result, nil
}
